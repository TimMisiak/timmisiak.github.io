<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TimDbg</title><link>/</link><description>Recent content on TimDbg</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Aug 2022 08:30:09 -0700</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Symbol and Binary Indexing</title><link>/posts/symbol-indexing/</link><pubDate>Wed, 10 Aug 2022 08:30:09 -0700</pubDate><guid>/posts/symbol-indexing/</guid><description>Symbol indexing is one of those features of WinDbg that can make things &amp;ldquo;just work&amp;rdquo; in a way that seems like magic. But it can also be the most painful things when it goes wrong.
Why should I index symbols and binaries? Most of us have tried to debug without symbols at one point, and it can quickly become an exercise in frustration. It&amp;rsquo;s much more productive to debug an executable where you have symbols because it gives you function names, variable names, type definitions, and source files.</description></item><item><title>Remote debugging</title><link>/remote-debugging/</link><pubDate>Fri, 05 Aug 2022 07:00:00 -0700</pubDate><guid>/remote-debugging/</guid><description>A key feature of WinDbg and NTSD is the ability to debug a target &amp;ldquo;remotely&amp;rdquo; from a separate computer. For kernel debugging, this is often the only way to debug, since the entire OS is &amp;ldquo;frozen&amp;rdquo; when broken into a kernel debugger. Remote debugging is also available for usermode debugging, and is often just as useful. Sometimes it&amp;rsquo;s useful because the target that you are testing on is different from the one you are using for development.</description></item><item><title>Remote Debugging</title><link>/posts/remote-debugging/</link><pubDate>Fri, 05 Aug 2022 00:52:15 -0700</pubDate><guid>/posts/remote-debugging/</guid><description>A key feature of WinDbg and NTSD is the ability to debug a target &amp;ldquo;remotely&amp;rdquo; from a separate computer. For kernel debugging, this is often the only way to debug, since the entire OS is &amp;ldquo;frozen&amp;rdquo; when broken into a kernel debugger. Remote debugging is also available for usermode debugging, and is often just as useful. Sometimes it&amp;rsquo;s useful because the target that you are testing on is different from the one you are using for development.</description></item><item><title>My new blog</title><link>/posts/first-post/</link><pubDate>Thu, 04 Aug 2022 11:15:04 -0700</pubDate><guid>/posts/first-post/</guid><description>Hi everyone! Since I started tweeting about WinDbg and debugging, I&amp;rsquo;ve been thinking about some longer things I want to write that don&amp;rsquo;t really fit on twitter. I&amp;rsquo;ve done a few of these as videos on my YouTube channel, but those are time consuming to make and most people don&amp;rsquo;t seem to watch the whole video. So I think a lot of what I want to talk about is probably best suited for a blog format.</description></item><item><title/><link>/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/about/</guid><description>Tim Misiak I&amp;rsquo;ve been working on debuggers and diagnostics for most of my professional career as a software engineer. For more than a decade, I&amp;rsquo;ve been working on the Microsoft Debugger Platform team, working on tools such as WinDbg and KD. I started the WinDbgNext project in 2016 that modernized WinDbg UI. I also wrote a chunk of the X86/X64 emulator used by Time Travel Debugging.
YouTube: Tim Misiak Twitter: @timmisiak GitHub: TimMisiak</description></item></channel></rss>