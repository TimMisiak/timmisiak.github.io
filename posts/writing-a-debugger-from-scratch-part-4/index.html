<!doctype html><html lang=en-us><head><title>Writing a Debugger From Scratch - DbgRs Part 4 - Exports and Private Symbols // TimDbg</title>
<link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.125.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX")}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing a Debugger From Scratch - DbgRs Part 4 - Exports and Private Symbols"><meta name=twitter:description content="(New to this series? Consider starting from part 1)
At the end of the last post, we had the ability to read memory out of the target process, but we still had very little in the way of interpreting the data in that process. That changes in this post, where we will start grabbing useful information out of the target, including modules, exports, and even private symbols.
The code for this post is in the part4 branch on github."><meta property="og:url" content="/posts/writing-a-debugger-from-scratch-part-4/"><meta property="og:site_name" content="TimDbg"><meta property="og:title" content="Writing a Debugger From Scratch - DbgRs Part 4 - Exports and Private Symbols"><meta property="og:description" content="(New to this series? Consider starting from part 1)
At the end of the last post, we had the ability to read memory out of the target process, but we still had very little in the way of interpreting the data in that process. That changes in this post, where we will start grabbing useful information out of the target, including modules, exports, and even private symbols.
The code for this post is in the part4 branch on github."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-29T15:28:40-07:00"><meta property="article:modified_time" content="2023-05-29T15:28:40-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Writing a Debugger From Scratch - DbgRs Part 4 - Exports and Private Symbols</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
May 29, 2023</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
15 min read</div></div></header><div class=post-content><p>(New to this series? Consider starting from <a href=/posts/writing-a-debugger-from-scratch-part-1>part 1</a>)</p><p>At the end of the <a href=/posts/writing-a-debugger-from-scratch-part-3>last post</a>, we had the ability to read memory out of the target process, but we still had very little in the way of interpreting the data in that process. That changes in this post, where we will start grabbing useful information out of the target, including modules, exports, and even private symbols.</p><p>The code for this post is in the <a href=https://github.com/TimMisiak/dbgrs/tree/part4>part4 branch on github</a>. If you see any mistakes or ways to improve the code, feel free to <a href=https://github.com/TimMisiak/dbgrs/issues>create issues</a> in the GitHub repo or submit a PR.</p><h1 id=where-are-the-modules>Where are the modules?</h1><p>Before we can start reading the exports or private symbols of a module, we need to know what modules are loaded and where they are loaded. We already have a handler for LOAD_DLL_DEBUG_EVENT that comes from WaitForDebugEventEx, which includes both the address and the name. We&rsquo;ll keep a list of all loaded modules so we can easily find which module is associated with an address, and then consult the information for that module to map the address to a name. Since a loaded module instance is associated with a process, we&rsquo;ll create a Process struct to keep track of all of the loaded modules.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Process</span> {
</span></span><span style=display:flex><span>    module_list: <span style=color:#a6e22e>std</span>::vec::Vec<span style=color:#f92672>&lt;</span>Module<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ll make a function for adding a module to the loaded list, and defer to the Module object for doing the parsing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Process {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Process</span> {
</span></span><span style=display:flex><span>        Process { module_list: Vec::new() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_module</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, address: <span style=color:#66d9ef>u64</span>, name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>, memory_source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource) -&gt;
</span></span><span style=display:flex><span>            Result<span style=color:#f92672>&lt;&amp;</span>Module, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> module <span style=color:#f92672>=</span> Module::from_memory_view(address, name, memory_source)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        self.module_list.push(module);
</span></span><span style=display:flex><span>        Ok(self.module_list.last().unwrap())
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=pe32><figure><img src=/pe32.svg#pe32 alt="PE32 structure"><figcaption><p>PE32 structure</p></figcaption></figure><p><small>Originally from <a href=https://en.wikipedia.org/wiki/File:Portable_Executable_32_bit_Structure_in_SVG_fixed.svg>Wikipedia</a>. Modified by cropping to content. Licensed under <a href=https://creativecommons.org/licenses/by/4.0/deed.en>CC BY 4.0</a></small></p></div><p>We&rsquo;re passing in all the information that will be needed to understand the module, which is essentially just the address of the module and the memory source to read the data from. We&rsquo;ll also pass in the module name given from the load event if it&rsquo;s available. If it&rsquo;s not available, we&rsquo;ll get the name from the loaded image in the <a aria-describedby=footnote-label href=#process-name>target process</a>.</p><p>Now we&rsquo;re ready to start parsing the information in the module. Windows modules are generally &ldquo;PE files&rdquo;, or &ldquo;Portable Executable&rdquo;. The PE format is <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format>fairly well documented</a>, but it will be easier to understand if you look at a diagram of the structure. The diagram to the right is the 32-bit PE format (PE32), but this is essentially the same as the 64-bit format (PE32+) with a <a aria-describedby=footnote-label href=#pe32-64>few small differences</a>.</p><p>The first few headers are there for legacy reasons. The <code>IMAGE_DOS_HEADER</code> exists so that executables would be recognized by DOS. At the end of this header is a field called <code>e_lfanew</code> which is the offset to the &ldquo;real&rdquo; header. The &ldquo;DOS stub&rdquo; that is after this header was used so that a Windows executable run under DOS would display a message saying &ldquo;This program cannot be run in DOS mode&rdquo;. That stub weirdly persists to this day, and even exists in DLLs where it&rsquo;s hard to imagine anyone would try to run them directly.</p><p>We can ignore everything else in the DOS header and go straight to reading the &ldquo;real&rdquo; header, which is the Windows header. This part is a few structs that are laid out consecutively in memory, and the &ldquo;optional&rdquo; header <a aria-describedby=footnote-label href=#optional-header>isn&rsquo;t really optional for image files</a>, so we can read them all at once as a single structure read. Conveniently, the <a href=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64><code>IMAGE_NT_HEADERS64</code></a> struct contains the <code>IMAGE_FILE_HEADER</code> (called &ldquo;COFF Header&rdquo; in the diagram) and the <a href=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header64><code>IMAGE_OPTIONAL_HEADER64</code></a> (called the &ldquo;optional header&rdquo; in the diagram). A few fields are interesting here, such as the <a aria-describedby=footnote-label href=#size-of-image>SizeOfImage field that tells us how large the image is</a>.</p><p>There are two tables in the header that describe the rest of the data in the file. The first is the &ldquo;section table&rdquo; which describes how each part of the image file should be loaded into memory, including information like what address the section should be loaded at and the size of the section. It also contains flags marking whether the section should be readable, writable, and/or executable. For instance, any sections containing code should be marked as readable and executable, while sections containing globals should be readable and writable. Each section also has a name. The names can be nearly anything, although there are some <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#special-sections>reserved names with special meaning</a>, such as &ldquo;.text&rdquo; for the code section or &ldquo;.data&rdquo; for initialized data. Note that most &ldquo;pointers&rdquo; to data in the file are described as &ldquo;RVAs&rdquo; or &ldquo;<a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#general-concepts>Relative Virtual Addresses</a>&rdquo;. This means that the address are relative to the start of the image <em>after</em> it&rsquo;s loaded into memory. This is important to know when interpreting a file on disk, but since we are reading from images that are already loaded into memory with sections at the expected addresses, we can ignore the section table for the moment. Each time we see an RVA, we can just add it to the module base address and we&rsquo;ll get the correct location.</p><p>The second table is the &ldquo;directory table&rdquo;, and is the more interesting one for us right now. The size of the table is described by the NumberOfRvaAndSizes field of the optional header and is typically 16 entries. Each entry of the table just has an RVA and length describing the location of the data. The role of each entry is determined by the index. For instance, the export table is always at index 0 and has a corresponding constant <code>IMAGE_DIRECTORY_ENTRY_EXPORT</code>. You can see this as the first entry in the diagram on the right, labled &ldquo;ExportTable&rdquo;.</p><p>Although this has been a long explanation describing the structure of the headers, all we need to do so far is to read the DOS header, find the offset to the Windows header, and then read the Windows header so that we can get to the data directories.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Module {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_memory_view</span>(module_address: <span style=color:#66d9ef>u64</span>, module_name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>, memory_source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource) -&gt; 
</span></span><span style=display:flex><span>            Result<span style=color:#f92672>&lt;</span>Module, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dos_header: <span style=color:#a6e22e>IMAGE_DOS_HEADER</span> <span style=color:#f92672>=</span> memory::read_memory_data(memory_source, module_address)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// NOTE: Do we trust that the headers are accurate, even if it means we could read outside the bounds of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//       module? For this debugger, we&#39;ll trust the data, but a real debugger should do sanity checks and 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//       report discrepancies to the user in some way.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> pe_header_addr <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> dos_header.e_lfanew <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// NOTE: This should be IMAGE_NT_HEADERS32 on x86 processes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> pe_header: <span style=color:#a6e22e>IMAGE_NT_HEADERS64</span> <span style=color:#f92672>=</span> memory::read_memory_data(memory_source, pe_header_addr)<span style=color:#f92672>?</span>;
</span></span></code></pre></div><h2 id=the-export-table>The export table</h2><p>Now that we have read the data directories, we can find the export table. The export table of a DLL has a list of names and the corresponding addresses for those names. Much like static linking, where function names are resolved to addresses at compile time, the export table allows function names to be resolved dynamically at runtime, thus the name &ldquo;Dynamic Link Library&rdquo;. This means that even for a DLL with no private symbols, we will still know the address of any <a aria-describedby=footnote-label href=#data-exports>functions that are exported</a>. While exports generally have names, it&rsquo;s also possible for exports to be referenced by &ldquo;ordinal&rdquo;, which is just an index into the export table.</p><p>The exports are described by the <a href=https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/SystemServices/struct.IMAGE_EXPORT_DIRECTORY.html><code>IMAGE_EXPORT_DIRECTORY</code></a> structure. We can read this using the address from the directory table.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_exports</span>(pe_header: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>IMAGE_NT_HEADERS64</span>, module_address: <span style=color:#66d9ef>u64</span>, memory_source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource) -&gt;
</span></span><span style=display:flex><span>        Result<span style=color:#f92672>&lt;</span>(Vec::<span style=color:#f92672>&lt;</span>Export<span style=color:#f92672>&gt;</span>, Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>), <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> exports <span style=color:#f92672>=</span> Vec::<span style=color:#f92672>&lt;</span>Export<span style=color:#f92672>&gt;</span>::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> module_name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> export_table_info <span style=color:#f92672>=</span> pe_header.OptionalHeader.DataDirectory[<span style=color:#66d9ef>IMAGE_DIRECTORY_ENTRY_EXPORT</span>.<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> export_table_info.VirtualAddress <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> export_table_addr <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> export_table_info.VirtualAddress <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> export_table_end <span style=color:#f92672>=</span> export_table_addr <span style=color:#f92672>+</span> export_table_info.Size <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> export_directory: <span style=color:#a6e22e>IMAGE_EXPORT_DIRECTORY</span> <span style=color:#f92672>=</span> memory::read_memory_data(memory_source, export_table_addr)<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>Besides the exports themselves, this structure may also contain the name of the module. We&rsquo;ll use that as another source of information if we don&rsquo;t already have the module name:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#75715e>// This is a fallback that lets us find a name if none was available.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> export_directory.Name <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> name_addr <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> export_directory.Name <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>            module_name <span style=color:#f92672>=</span> Some(memory::read_memory_string(memory_source, name_addr, <span style=color:#ae81ff>512</span>, <span style=color:#66d9ef>false</span>)<span style=color:#f92672>?</span>);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>The exports are described as two logical tables. The first is the addresses of the functions themselves as 32-bit RVAs and is described by the <code>AddressOfFunctions</code> and <code>NumberOfFunctions</code> fields.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#66d9ef>let</span> address_table_address <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> export_directory.AddressOfFunctions <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> address_table <span style=color:#f92672>=</span> memory::read_memory_full_array::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>(memory_source,
</span></span><span style=display:flex><span>                                                                  address_table_address,
</span></span><span style=display:flex><span>                                                                  export_directory.NumberOfFunctions <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>The second table is the &ldquo;name table&rdquo; which maps ordinals to names. It is a single logical table stored in the file as two parallel arrays, one containing the ordinals and one containing <a aria-describedby=footnote-label href=#name-ordinal-table>RVAs to the names</a>. The <code>NumberOfNames</code> field describes the number of entries in both arrays, and the <code>AddressOfNameOrdinals</code> and <code>AddressOfNames</code> are the RVAs to each array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#75715e>// We&#39;ll read the name table first, which is essentially a list of (ordinal, name) pairs that give names 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// to some or all of the exports. The table is stored as parallel arrays of orindals and name pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> ordinal_array_address <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> export_directory.AddressOfNameOrdinals <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ordinal_array <span style=color:#f92672>=</span> memory::read_memory_full_array::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u16</span><span style=color:#f92672>&gt;</span>(memory_source,
</span></span><span style=display:flex><span>                                                                  ordinal_array_address,
</span></span><span style=display:flex><span>                                                                  export_directory.NumberOfNames <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> name_array_address <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> export_directory.AddressOfNames <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> name_array <span style=color:#f92672>=</span> memory::read_memory_full_array::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>(memory_source,
</span></span><span style=display:flex><span>                                                               name_array_address,
</span></span><span style=display:flex><span>                                                               export_directory.NumberOfNames <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>As I mentioned previously, not all exports have names. These can be referenced by &ldquo;ordinal&rdquo;, which is an index into the table. The <code>Base</code> field of the export table describes the ordinal of the first element of the table. So if this value is 100, then finding ordinal 105 in the export would be at index number 5 in the address table.</p><p>The last piece of information needed for parsing this table is that some entries in the address table are &ldquo;<a href="https://devblogs.microsoft.com/oldnewthing/20060719-24/?p=30473">forwarders</a>&rdquo;. These entries describe exports that are forwarded to another DLL by name, and will be resolved to the export in a target DLL. Any address that points to data inside the export section is forwarder, and is pointing to a string in the form of &ldquo;MODULENAME.EXPORTNAME&rdquo;, where MODULENAME is a dll name and EXPORTNAME is either a function name like &ldquo;NTDLL.RtlAcquireSRWLockExclusive&rdquo; or an ordinal with a &lsquo;#&rsquo; prefix, such as &ldquo;NTDLL.#24&rdquo;. If the target address is outside the export section, it is a normal export.</p><p>We&rsquo;ll build up a table of all exports so that we can quickly look up addresses. To start, we&rsquo;ll iterate over the address table.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (unbiased_ordinal, function_address) <span style=color:#66d9ef>in</span> address_table.iter().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> ordinal <span style=color:#f92672>=</span> export_directory.Base <span style=color:#f92672>+</span> unbiased_ordinal <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> target_address <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> <span style=color:#f92672>*</span>function_address <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span></code></pre></div><p>Then we&rsquo;ll check if the name table has an entry for this ordinal, and read it from the target process if it exists.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            <span style=color:#66d9ef>let</span> name_index <span style=color:#f92672>=</span> ordinal_array.iter().position(<span style=color:#f92672>|&amp;</span>o<span style=color:#f92672>|</span> o <span style=color:#f92672>==</span> unbiased_ordinal <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u16</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> export_name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> name_index {
</span></span><span style=display:flex><span>                None <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>                Some(idx) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> name_address <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> name_array[idx] <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>                    Some(memory::read_memory_string(memory_source, name_address, <span style=color:#ae81ff>4096</span>, <span style=color:#66d9ef>false</span>)<span style=color:#f92672>?</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span></code></pre></div><p>Finally, we&rsquo;ll check if this export is a normal export or if it&rsquo;s a forwarder. We&rsquo;ll add this to an &ldquo;exports&rdquo; list, and store this as part of the Module struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            <span style=color:#75715e>// An address that falls inside the export directory is actually a forwarder
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> target_address <span style=color:#f92672>&gt;=</span> export_table_addr <span style=color:#f92672>&amp;&amp;</span> target_address <span style=color:#f92672>&lt;</span> export_table_end {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// I don&#39;t know that there actually is a max size for a forwader name, but 4K is probably reasonable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> forwarding_name <span style=color:#f92672>=</span> memory::read_memory_string(memory_source, target_address, <span style=color:#ae81ff>4096</span>, <span style=color:#66d9ef>false</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                exports.push(Export {name: <span style=color:#a6e22e>export_name</span>, ordinal, target: <span style=color:#a6e22e>ExportTarget</span>::Forwarder(forwarding_name)});                    
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                exports.push(Export{name: <span style=color:#a6e22e>export_name</span>, ordinal, target: <span style=color:#a6e22e>ExportTarget</span>::<span style=color:#66d9ef>RVA</span>(target_address)});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><h2 id=private-symbols>Private symbols</h2><p>There is another source of names we can use, and that&rsquo;s from private symbols. To find the corresponding private symbols for a binary, we need to look at the debug directory, which is at the <code>IMAGE_DIRECTORY_ENTRY_DEBUG</code> index of the directory table. The debug directory is itself a table of <code>IMAGE_DEBUG_DIRECTORY</code> structs, and we can determine how many are available based on the size of the debug directory. There are a few different types of debug info that can be stored here, but the one we care about for now is the &ldquo;codeview&rdquo; entry.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> debug_table_info <span style=color:#f92672>=</span> pe_header.OptionalHeader.DataDirectory[<span style=color:#66d9ef>IMAGE_DIRECTORY_ENTRY_DEBUG</span>.<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> debug_table_info.VirtualAddress <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dir_size <span style=color:#f92672>=</span> std::mem::size_of::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>IMAGE_DEBUG_DIRECTORY</span><span style=color:#f92672>&gt;</span>() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We&#39;ll arbitrarily limit to 20 entries to keep it sane.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> count: <span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> std::cmp::min(debug_table_info.Size <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span> <span style=color:#f92672>/</span> dir_size, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> dir_index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>count {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> debug_directory_address <span style=color:#f92672>=</span> module_address <span style=color:#f92672>+</span> (debug_table_info.VirtualAddress <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>) <span style=color:#f92672>+</span> (dir_index <span style=color:#f92672>*</span> dir_size);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> debug_directory: <span style=color:#a6e22e>IMAGE_DEBUG_DIRECTORY</span> <span style=color:#f92672>=</span> memory::read_memory_data(memory_source, debug_directory_address)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> debug_directory.Type <span style=color:#f92672>==</span> <span style=color:#66d9ef>IMAGE_DEBUG_TYPE_CODEVIEW</span> {
</span></span></code></pre></div><p>The CodeView entry has a signature, a guid, an &ldquo;age&rdquo;, and a name.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[repr(C)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PdbInfo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> signature: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> guid: <span style=color:#a6e22e>windows</span>::core::<span style=color:#66d9ef>GUID</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> age: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Null terminated name goes after the end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>We can use this struct to read the data from the table.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#66d9ef>let</span> pdb_info_address <span style=color:#f92672>=</span> debug_directory.AddressOfRawData <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span> <span style=color:#f92672>+</span> module_address;
</span></span><span style=display:flex><span>        pdb_info <span style=color:#f92672>=</span> Some(memory::read_memory_data(memory_source, pdb_info_address)<span style=color:#f92672>?</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We could check that pdb_info.signature is RSDS here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> pdb_name_address <span style=color:#f92672>=</span> pdb_info_address <span style=color:#f92672>+</span> std::mem::size_of::<span style=color:#f92672>&lt;</span>PdbInfo<span style=color:#f92672>&gt;</span>() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        pdb_name <span style=color:#f92672>=</span> Some(memory::read_memory_string(memory_source, pdb_name_address, <span style=color:#ae81ff>260</span>, <span style=color:#66d9ef>false</span>)<span style=color:#f92672>?</span>);
</span></span></code></pre></div><p>We could use the fields of the struct to download the symbols from a symbol server or symbol cache, but we&rsquo;ll leave that functionality for later. For now we&rsquo;ll assume that the name points to an absolute path on disk and use the <a href=https://crates.io/crates/pdb>pdb crate</a> to load the data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#66d9ef>let</span> pdb_file <span style=color:#f92672>=</span> File::open(pdb_name.as_ref().unwrap());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(pdb_file) <span style=color:#f92672>=</span> pdb_file {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> pdb_data <span style=color:#f92672>=</span> <span style=color:#66d9ef>PDB</span>::open(pdb_file);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(pdb_data) <span style=color:#f92672>=</span> pdb_data {
</span></span><span style=display:flex><span>                pdb <span style=color:#f92672>=</span> Some(pdb_data);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><h2 id=name-resolution>Name resolution</h2><p>Now that we have exports and private symbols, we can start to resolve addresses to names as we are debugging. We&rsquo;ll create a new function called <code>resolve_address_to_name</code> that takes a process and an address and returns a symbol name with offset if it can be found.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>resolve_address_to_name</span>(address: <span style=color:#66d9ef>u64</span>, process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Process) -&gt; Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> module <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> process.get_containing_module_mut(address) {
</span></span><span style=display:flex><span>        Some(module) <span style=color:#f92672>=&gt;</span> module,
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> None
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div><p>For now we&rsquo;ll just do a linear search over the exports and find the closest export that comes before the address we are mapping.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>for</span> export <span style=color:#66d9ef>in</span> module.exports.iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> ExportTarget::<span style=color:#66d9ef>RVA</span>(export_addr) <span style=color:#f92672>=</span> export.target {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> export_addr <span style=color:#f92672>&lt;=</span> address {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> closest.is_none() <span style=color:#f92672>||</span> closest_addr <span style=color:#f92672>&lt;</span> export_addr {
</span></span><span style=display:flex><span>                    closest <span style=color:#f92672>=</span> AddressMatch::Export(export);
</span></span><span style=display:flex><span>                    closest_addr <span style=color:#f92672>=</span> export_addr;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>We&rsquo;ll do the same thing for the symbols in the pdb. Once we find the closest match, we&rsquo;ll return a string that represents the symbol and add a &ldquo;+offset&rdquo; suffix if the address isn&rsquo;t an exact match.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> AddressMatch::Export(closest) <span style=color:#f92672>=</span> closest {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> offset <span style=color:#f92672>=</span> address <span style=color:#f92672>-</span> closest_addr;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> sym_with_offset <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> offset <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>!</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>&amp;</span>module.name, closest.to_string())
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>!</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>+0x</span><span style=color:#e6db74>{:X}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>&amp;</span>module.name, closest.to_string(), offset)
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Some(sym_with_offset)
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now that we can resolve an address to a string, we can resolve the instruction pointer to a name each time the debugger breaks in.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(sym) <span style=color:#f92672>=</span> name_resolution::resolve_address_to_name(ctx.context.Rip, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> process) {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[</span><span style=color:#e6db74>{:X}</span><span style=color:#e6db74>] </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, debug_event.dwThreadId, sym);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[</span><span style=color:#e6db74>{:X}</span><span style=color:#e6db74>] </span><span style=color:#e6db74>{:#018x}</span><span style=color:#e6db74>&#34;</span>, debug_event.dwThreadId, ctx.context.Rip);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And to let us look up any address we want, we&rsquo;ll add a command called <code>ln</code> to let us look up a given address.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    CommandExpr::ListNearest(_, expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> val <span style=color:#f92672>=</span> eval::evaluate_expression(<span style=color:#f92672>*</span>expr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(sym) <span style=color:#f92672>=</span> name_resolution::resolve_address_to_name(val, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> process) {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, sym);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;No symbol found&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=testing-it-out>Testing it out</h2><p>Let&rsquo;s see it all in action!</p><pre tabindex=0><code>Command line was: &#39;&#34;C:\git\HelloWorld\hello.exe&#34; &#39;
CreateProcess
LoadDll: 7FF7D9D20000   hello.exe
[2E86C] 0x00007fff20eea9d0
&gt; g
LoadDll: 7FFF20E90000   ntdll.dll
[2E86C] ntdll.dll!RtlUserThreadStart
&gt; ln 0x00007ff7d9d27100  
hello.exe!main
[2E86C] ntdll.dll!RtlUserThreadStart
&gt; g
LoadDll: 7FFF1FCA0000   C:\Windows\System32\KERNEL32.DLL
[2E86C] ntdll.dll!NtMapViewOfSection+0x14
&gt;
</code></pre><p>It works! You&rsquo;ll note that on the very first break, we have a bare address that can&rsquo;t be resolved. That&rsquo;s because the LoadDll notification hasn&rsquo;t been received yet for ntdll, so we don&rsquo;t have enough information to resolve the address. On the second debug event, we get information about ntdll, which lets us resolve the address to <code>ntdll!RtlUserThreadStart</code>. Finally, we try to resolve the address for a private symbol, which you can see resolves to <code>hello!main</code>.</p><p>This post is a big step for dbgrs, since we&rsquo;re finally interpreting things in a more human friendly way. There&rsquo;s still not quite enough functionality here to do anything useful though, since we can&rsquo;t really control the state of the target in a way that lets us do any interesting debugging. I think the lack of breakpoints is the biggest weakness. Now that we have some basic symbol resolution, we have what we need to start building that functionality, and that&rsquo;s where we&rsquo;ll work on in the next post.</p><p>Hope you found this post interesting and informative! Have a question or suggestion? Let me know! You can find me on <a href=https://twitter.com/timmisiak>Twitter</a> or <a href=https://dbg.social/@tim>Mastodon</a>.</p><footer><h2 id=footnote-label>Footnotes</h2><ol><li id=process-name>There are a bunch of different sources of information you could use as the name of a module. You could use the name from the debug event (if present), the name from the file handle from the debug event, the name from the export table (if present), the name from the resource table (if present), or even derive the name from the debug directory. Maybe even some more sources that I'm forgetting. The tricky part is that there's no reason why all four of these need to match, and they are often different! Add this to the fact that you could have two instances of the same module loaded, and the concept of a "module name" gets very complicated. We'll take a similar approach to what I believe WinDbg does, which is to prioritize the name from the module load event, and fall back to other sources if needed.</li><li id=pe32-64>Most fields are actually the same. The main differences are a few fields that are memory sizes or addresses, such as the ImageBase, and size of stack/heap reserve and commit. Many of the fields are RVAs, which are relative to the image base, so 32-bit offsets are generally fine.</li><li id=optional-header>It's called "optional" because much of this format is shared with object files and <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-image-only>object files do not have this header</a>.</li><li id=size-of-image>We could also get the size of image from the memory allocation, looking for the consecutive set of MEM_IMAGE allocations using VirtualQueryEx. Like so many other things about debugging a live process, the information can come from various sources and you need to pick which one to trust. If I were writing a real debugger and not one for educational purposes, I would consider reading all of the sources and reporting to the user whenever they don't match. Having multiple sources of information to cross check can be useful for cases such as corrupt files or hardware errors.</li><li id=data-exports>Strictly speaking, exports can be used for both functions and data. In practice, using exports for data is somewhat rare although it does happen. It's generally not a great design to have shared writable data exported, but I've seen it used to describe metadata about a module. <a href=https://developer.download.nvidia.com/devzone/devcenter/gamegraphics/files/OptimusRenderingPolicies.pdf>Nvidia</a> and <a href=https://gpuopen.com/learn/amdpowerxpressrequesthighperformance/>AMD</a> both have some special exports you can use to tell the drivers what performance mode you want. (Thanks <a href=https://twitter.com/molecularmusing/status/1662941499770695681>Stefan</a>!)</li><li id=name-ordinal-table>The tables are stored separately because the ordinals are 16 bit integers and the name RVAs are 32 bit integers. So instead of having an array of 48 bit elements, there is an array of 16 bit elements and an array of 32 bit elements, to keep everything aligned and avoid unaligned accesses (which can be slower on some architectures).</li></ol></footer></div><div class=post-footer></div></article></main></body></html>