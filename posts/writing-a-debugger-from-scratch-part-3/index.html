<!doctype html><html lang=en-us><head><title>Writing a Debugger From Scratch - DbgRs Part 3 - Reading Memory // TimDbg</title>
<link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.129.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX")}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing a Debugger From Scratch - DbgRs Part 3 - Reading Memory"><meta name=twitter:description content="(New to this series? Consider starting from part 1)
At the end of the last post, we had the ability to launch a program, step through instructions, and examine registers. We’re still not quite at the point that we can call this a “debugger” but we’re getting pretty close. In this part, we’re going to start implementing functionality to examine the memory of the target process. You can see the full code for this post in the part3 branch on github."><meta property="og:url" content="/posts/writing-a-debugger-from-scratch-part-3/"><meta property="og:site_name" content="TimDbg"><meta property="og:title" content="Writing a Debugger From Scratch - DbgRs Part 3 - Reading Memory"><meta property="og:description" content="(New to this series? Consider starting from part 1)
At the end of the last post, we had the ability to launch a program, step through instructions, and examine registers. We’re still not quite at the point that we can call this a “debugger” but we’re getting pretty close. In this part, we’re going to start implementing functionality to examine the memory of the target process. You can see the full code for this post in the part3 branch on github."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-28T10:14:19-07:00"><meta property="article:modified_time" content="2023-03-28T10:14:19-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Writing a Debugger From Scratch - DbgRs Part 3 - Reading Memory</h1><div class=post-meta><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Mar 28, 2023</div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
10 min read</div></div></header><div class=post-content><p>(New to this series? Consider starting from <a href=/posts/writing-a-debugger-from-scratch-part-1>part 1</a>)</p><p>At the end of the <a href=/posts/writing-a-debugger-from-scratch-part-2>last post</a>, we had the ability to launch a program, step through instructions, and examine registers. We&rsquo;re still not quite at the point that we can call this a &ldquo;debugger&rdquo; but we&rsquo;re getting pretty close. In this part, we&rsquo;re going to start implementing functionality to examine the memory of the target process. You can see the full code for this post in the <a href=https://github.com/TimMisiak/dbgrs/tree/part3>part3 branch on github</a>. If you see any mistakes or ways to improve the code, feel free to <a href=https://github.com/TimMisiak/dbgrs/issues>create issues</a> in the GitHub repo or submit a PR. I&rsquo;ve had a few folks contribute issues and PRs, which I really appreciate!</p><p>The simplest memory command we can implement will take an address as a parameter and display a hex dump of memory at that address. In WinDbg/NTSD, that command would be &ldquo;db&rdquo;, which is one of the <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/d--da--db--dc--dd--dd--df--dp--dq--du--dw--dw--dyb--dyd--display-memor>&ldquo;display memory&rdquo; commands</a>. We&rsquo;ll use the same abbreviation here. Before we can implement the functionality for &ldquo;db&rdquo;, we need to extend our command parser to accept numerical expressions.</p><h1 id=extending-the-command-parser>Extending the command parser</h1><p>Since the command parser is written using <a href=https://github.com/hydro-project/rust-sitter>Rust Sitter</a>, extending the parser to accept more complicated expressions is pretty straightforward. We&rsquo;ll rename the <code>Expr</code> enum to <code>CommandExpr</code> since we&rsquo;ll now have a new type of expression, which is one that can be evaluated as a numeric expression. We&rsquo;ll call that <code>EvalExpr</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#75715e>#[rust_sitter::language]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CommandExpr</span> {
</span></span><span style=display:flex><span>        StepInto(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;t&#34;</span><span style=color:#75715e>)]</span> ()),
</span></span><span style=display:flex><span>        Go(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;g&#34;</span><span style=color:#75715e>)]</span> ()),
</span></span><span style=display:flex><span>        DisplayRegisters(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;r&#34;</span><span style=color:#75715e>)]</span> ()),
</span></span><span style=display:flex><span>        DisplayBytes(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;db&#34;</span><span style=color:#75715e>)]</span> (), Box<span style=color:#f92672>&lt;</span>EvalExpr<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>        Evaluate(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;?&#34;</span><span style=color:#75715e>)]</span> (), Box<span style=color:#f92672>&lt;</span>EvalExpr<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>        Quit(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;q&#34;</span><span style=color:#75715e>)]</span> ()),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[rust_sitter::language]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>EvalExpr</span> {
</span></span><span style=display:flex><span>        Number(<span style=color:#75715e>#[rust_sitter::leaf(pattern = r</span><span style=color:#e6db74>&#34;(\d+|0x[0-9a-fA-F]+)&#34;</span><span style=color:#75715e>, transform = parse_int)]</span> <span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[rust_sitter::prec_left(1)]</span>
</span></span><span style=display:flex><span>        Add(
</span></span><span style=display:flex><span>            Box<span style=color:#f92672>&lt;</span>EvalExpr<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;+&#34;</span><span style=color:#75715e>)]</span> (),
</span></span><span style=display:flex><span>            Box<span style=color:#f92672>&lt;</span>EvalExpr<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><small><a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/command.rs>command.rs</a></small></p><p>In addition to adding the <code>EvalExpr</code> type, there are also two new commands which take an <code>EvalExpr</code>. The first is the <code>?</code> command which evaluates an expression. It will be a useful starting point to test parsing and evaluation of <code>EvalExpr</code>. The other command is <code>db</code>, which displays bytes at the address corresponding to the evaluated expression. For our numerical expression, we&rsquo;ll accept hexidecimal numbers or decimal numbers (using a &lsquo;0x&rsquo; prefix to denote hexidecimal), and we&rsquo;ll allow simple addition of terms with &ldquo;+&rdquo;. Note that the <code>prec_left</code> is to make the language unambiguous by saying that the operator is left-associative, so 1 + 2 + 3 means (1 + 2) + 3, which in our <a href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>AST</a> means <code>Add(Add(Number(1), Number(2)), Number(3))</code>.</p><p>The <code>transform</code> function needs to take a string and return an integer that gets used as the value for the Number enum, so we&rsquo;ll write a short function to do that conversion.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_int</span>(text: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> text <span style=color:#f92672>=</span> text.trim();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> text.starts_with(<span style=color:#e6db74>&#34;0x&#34;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> text <span style=color:#f92672>=</span> text.split_at(<span style=color:#ae81ff>2</span>).<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>u64</span>::from_str_radix(text, <span style=color:#ae81ff>16</span>).unwrap()
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            text.parse().unwrap()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><small><a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/command.rs>command.rs</a></small></p><h1 id=evaluating-expressions>Evaluating expressions</h1><p>For now, the evaluator doesn&rsquo;t support symbols or any operations except addition so it&rsquo;s pretty straightforward.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>evaluate_expression</span>(expr: <span style=color:#a6e22e>EvalExpr</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> expr {
</span></span><span style=display:flex><span>            EvalExpr::Number(x) <span style=color:#f92672>=&gt;</span> x,
</span></span><span style=display:flex><span>            EvalExpr::Add(x, _, y) <span style=color:#f92672>=&gt;</span> evaluate_expression(<span style=color:#f92672>*</span>x) <span style=color:#f92672>+</span> evaluate_expression(<span style=color:#f92672>*</span>y),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And this is all we need to implement the functionality for <code>CommandExpr::Evaluate</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    CommandExpr::Evaluate(_, expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> val <span style=color:#f92672>=</span> eval::evaluate_expression(<span style=color:#f92672>*</span>expr);
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34; = 0x</span><span style=color:#e6db74>{:X}</span><span style=color:#e6db74>&#34;</span>, val);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><small><a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/main.rs>main.rs</a></small></p><p>Let&rsquo;s test it out:</p><pre tabindex=0><code>Command line was: &#39;cmd.exe /k &#34;echo hello&#34; &#39;
CreateProcess
[CC04] 0x00007fff36e82680
&gt; ? 10 + 10
 = 0x14
[CC04] 0x00007fff36e82680
&gt; ? 0x10 + 10 
 = 0x1A
[CC04] 0x00007fff36e82680
&gt; ? 0x10 + 0x10 
 = 0x20
[CC04] 0x00007fff36e82680
</code></pre><h1 id=displaying-memory>Displaying memory</h1><p>Now that we can parse numeric expressions, we can hook up our memory display command. We start by evaluating the expression given.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    CommandExpr::DisplayBytes(_, expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> addr <span style=color:#f92672>=</span> eval::evaluate_expression(<span style=color:#f92672>*</span>expr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> buffer: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bytes_read: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p><small><a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/main.rs>main.rs</a></small></p><p>To read memory from another process, we use the <a href=https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory>ReadProcessMemory</a> API, which takes a set of parameters describing the process, address, number of bytes to read, and a local buffer pointer/length.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>            ReadProcessMemory(
</span></span><span style=display:flex><span>                process,
</span></span><span style=display:flex><span>                addr <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> c_void,
</span></span><span style=display:flex><span>                buffer.as_mut_ptr() <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void,
</span></span><span style=display:flex><span>                buffer.len(),
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> bytes_read <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> result <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;ReadProcessMemory failed&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> n <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>bytes_read {
</span></span><span style=display:flex><span>                print!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:02X}</span><span style=color:#e6db74> &#34;</span>, buffer[n]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            println!();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Using the instruction pointer, we have an address that we can use to dump the code bytes that we&rsquo;re executing.</p><pre tabindex=0><code>[CC04] 0x00007fff36e82680
&gt; db 0x00007fff36e82680
48 83 EC 78 4C 8B C9 48 8B 05 62 99 11 00 48 85 
</code></pre><p>I can recognize these bytes as x64 assembly code, so it looks like this is working. (How did I recognize these bytes as code? I wrote about this in my post about <a href=/posts/recognizing-patterns>recognizing patterns in memory</a>).</p><p>There are a few other places where reading memory can give us better information, but before we go any further we should wrap the ReadProcessMemory call so it&rsquo;s a bit easier and safer to use. We&rsquo;re going to need to read all sorts of data types of data, including things like UTF-16 strings<sup>1</sup>, and we don&rsquo;t want to see these verbose ReadProcessMemory calls everywhere. We&rsquo;ll also want to start creating a level of abstraction so that we can handle reading memory from other sources besides just a live process (for instance, crash dump files).</p><h1 id=memorysource-trait>MemorySource trait</h1><p>We&rsquo;ll define a Rust <a href=https://doc.rust-lang.org/book/ch10-02-traits.html>trait</a> that represents something that we can read memory from. Unlike dealing with memory within a process, reading memory from a different process often has to deal with &ldquo;partial&rdquo; reads where some part of the memory isn&rsquo;t available (such as an unmapped page, or memory missing in a crash dump). There are two ways to handle unavailable memory. You can either read as many contiguous bytes as are available, or you can return an array of items that represent the entire requested range with a flag on each one to indicate if it was available or not. Reading the largest contiguous range will be a function called <code>read_raw_memory</code> in this trait, and we will generally use this when we are reading data structures or strings out of the remote process. For displaying memory to a user with a <code>db</code> command, however, we want to indicate which bytes were available and which are not, and we will call this trait function <code>read_memory</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> MemorySource {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read up to &#34;len&#34; bytes, and stop at the first failure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_raw_memory</span>(<span style=color:#f92672>&amp;</span>self, address: <span style=color:#66d9ef>u64</span>, len: <span style=color:#66d9ef>usize</span>) -&gt; Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read up to &#34;len&#34; bytes, and return Option&lt;u8&gt; to represent what bytes are available in the range
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_memory</span>(<span style=color:#f92672>&amp;</span>self, address: <span style=color:#66d9ef>u64</span>, len: <span style=color:#66d9ef>usize</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;&gt;</span>, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><small><a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/memory.rs>memory.rs</a></small></p><p>On top of this trait, we&rsquo;ll have some helper functions that let us read strings and other structures. I&rsquo;ll leave the definitions out for brevity (and since they&rsquo;re not particularly interesting), but you can check the github repo to see how these are implemented.<sup>2</sup></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_memory_data</span><span style=color:#f92672>&lt;</span>T: Sized <span style=color:#f92672>+</span> Default <span style=color:#f92672>+</span> Copy<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource,
</span></span><span style=display:flex><span>    address: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>) -&gt; Result<span style=color:#f92672>&lt;</span>T, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> { <span style=color:#f92672>..</span>. }
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_memory_array</span><span style=color:#f92672>&lt;</span>T: Sized <span style=color:#f92672>+</span> Default<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource,
</span></span><span style=display:flex><span>    address: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>    max_count: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>) -&gt; Result<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> { <span style=color:#f92672>..</span>. }
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_memory_string</span>(
</span></span><span style=display:flex><span>    source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource,
</span></span><span style=display:flex><span>    address: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>    max_count: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    is_wide: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>) -&gt; Result<span style=color:#f92672>&lt;</span>String, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> { <span style=color:#f92672>..</span>. }
</span></span></code></pre></div><p><small><a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/memory.rs>memory.rs</a></small></p><h1 id=reading-debug-output-strings>Reading debug output strings</h1><p>Now that we can easily read structures and strings from the remote process, we can improve our handling of a few debug events to give better information to users. The obvious one to start with is <code>OUTPUT_DEBUG_STRING_EVENT</code> which will tell us the text that a target process passes to <a href=https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringw><code>OutputDebugStringW</code></a>.</p><p>The <code>OUTPUT_DEBUG_STRING_EVENT</code> constant corresponds to the <code>OUTPUT_DEBUG_STRING_INFO</code> struct in the event union. Output strings could be windows &ldquo;wide&rdquo; or &ldquo;ANSI&rdquo; depending on if <code>OutputDebugStringA</code> or <code>OutputDebugStringW</code> is used. The <code>fUnicode</code> member tells us which to expect. The address is given in <code>lpDebugStringData</code> and this is an address in the target process address space. We also get the length of the string, which makes it convenient to know how much memory we should try to read. We can read the string using the <code>read_memory_string</code> helper that we just added.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>OUTPUT_DEBUG_STRING_EVENT</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> debug_string_info <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { debug_event.u.DebugString };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> is_wide <span style=color:#f92672>=</span> debug_string_info.fUnicode <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> address <span style=color:#f92672>=</span> debug_string_info.lpDebugStringData <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> debug_string_info.nDebugStringLength <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> debug_string <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            memory::read_memory_string(mem_source.as_ref(), address, len, is_wide).unwrap();
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;DebugOut: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, debug_string);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>To test this, I wrote a short C++ program that calls the two debug output APIs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    OutputDebugStringA(<span style=color:#e6db74>&#34;Hello world!&#34;</span>);
</span></span><span style=display:flex><span>    OutputDebugStringW(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;Hello Unicode world!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Running this under our debugger and we get the expected output. It&rsquo;s alive!</p><pre tabindex=0><code>&gt; g
DebugOut: Hello world!
[CDB8] 0x00007ffd3b6fcd29
&gt; g
DebugOut: Hello Unicode world!
[CDB8] 0x00007ffd3b6fcd29
</code></pre><h1 id=better-module-load-notifications>Better module load notifications</h1><p>Now that we have debug output strings displaying, we can move on to module load notifications. Right now, there isn&rsquo;t any useful information being displayed, but the Windows <a href=https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-waitfordebugeventex>WaitForDebugEventEx</a> API will helpfully provide a pointer to a module name as part of the <code>LOAD_DLL_DEBUG_EVENT</code>. Reading the module name is slightly more complicated than the debug strings, because the provided field is actually the address of a pointer to the string, so we have an extra level of indirection to deal with, but otherwise is very similar. We can use the <code>read_memory_data</code> helper to grab the pointer, and then read the actual string using <code>read_memory_string</code> again. Note that the event does not tell us how long the string is, so we&rsquo;ll just assume that the modules won&rsquo;t be longer than <code>MAX_PATH</code> (260).</p><p>Note that the <code>lpImageName</code> field is not always provided, so we have to handle the case where this is null. There are other ways we can determine the name of a module from the provided information, but we&rsquo;ll leave that for the future.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>LOAD_DLL_DEBUG_EVENT</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> load_dll <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { debug_event.u.LoadDll };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dll_base: <span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> load_dll.lpBaseOfDll <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> load_dll.lpImageName <span style=color:#f92672>!=</span> std::ptr::null_mut() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> dll_name_address <span style=color:#f92672>=</span> memory::read_memory_data::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>                mem_source.as_ref(),
</span></span><span style=display:flex><span>                load_dll.lpImageName <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            .unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> is_wide <span style=color:#f92672>=</span> load_dll.fUnicode <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> dll_name <span style=color:#f92672>=</span> memory::read_memory_string(
</span></span><span style=display:flex><span>                mem_source.as_ref(),
</span></span><span style=display:flex><span>                dll_name_address,
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>260</span>,
</span></span><span style=display:flex><span>                is_wide,
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;LoadDll: </span><span style=color:#e6db74>{:X}</span><span style=color:#e6db74>   </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, dll_base, dll_name);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;LoadDll: </span><span style=color:#e6db74>{:X}</span><span style=color:#e6db74>&#34;</span>, dll_base);
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><small><a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/main.rs>main.rs</a></small></p><p>Testing this again and we see the expected output!</p><pre tabindex=0><code>Command line was: &#39;cmd.exe /k &#34;echo hello&#34; &#39;
CreateProcess
[BD14] 0x00007ffd3d9e2680
&gt; g
LoadDll: 7FFD3D990000    
[BD14] 0x00007ffd3d9e2680
&gt; g
LoadDll: 7FFD3CD20000   C:\WINDOWS\System32\KERNEL32.DLL
[BD14] 0x00007ffd3da2d5c4
&gt; g
LoadDll: 7FFD3B6D0000   C:\WINDOWS\System32\KERNELBASE.dll
[BD14] 0x00007ffd3da2d5c4
&gt; g
LoadDll: 7FFD3D5B0000   C:\WINDOWS\System32\msvcrt.dll
[BD14] 0x00007ffd3da2d5c4
</code></pre><p>You might note that the very first module load is missing a name, and this is one of the cases where the provided <code>lpImageName</code> field is null. Using an instance of WinDbg with a <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/noninvasiv-debugging--user-mode->noninvasive attach</a>, we can use the <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/-dh>!dh</a> or <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/-imgscan--find-image-headers->.imgscan</a> commands to examine the module at that address.</p><pre tabindex=0><code>0:000&gt; .imgscan
MZ at 00007ff7`cb470000, prot 00000002, type 01000000 - size 67000
  Name: cmd.exe
MZ at 00007ffd`3d990000, prot 00000002, type 01000000 - size 1f8000
  Name: ntdll.dll

  0:000&gt; !dh 7FFD3D990000

File Type: DLL
FILE HEADER VALUES
    8664 machine (X64)
...
Debug Directories(4)
	Type       Size     Address  Pointer
	cv           22      140160   13d360	Format: RSDS, guid, 1, ntdll.pdb
</code></pre><p>From this output, we can see that the module is ntdll.dll, which is definitely a bit of a &ldquo;special&rdquo; module so it&rsquo;s not really a surprise that it&rsquo;s the only module with a missing name. We could add some additional logic to deduce the module name when it isn&rsquo;t returned as part of the <code>LOAD_DLL_DEBUG_EVENT</code>, but we can revisit this once we do more interpretation of the memory in a module.</p><h1 id=memory-done-whats-next>Memory done, what&rsquo;s next?</h1><p>At this point, we&rsquo;ve created something that can read lots of different types of raw data from a target, but we still don&rsquo;t have a lot of interpretation happening. We need to interpret code bytes, modules, symbol names, and data types, to name a few. That&rsquo;s a lot to tackle, but next time we will start with a few of these.</p><p>Are you enjoying this series? Have a question or suggestion? Let me know! You can find me on <a href=https://twitter.com/timmisiak>Twitter</a> or <a href=https://dbg.social/@tim>Mastodon</a>.</p><h2 id=footnotes>Footnotes</h2><p><sup>1</sup> I always feel weird calling Windows wide strings &ldquo;UTF-16&rdquo;, because that&rsquo;s not quite right, for a number of reasons (for instance, most Windows APIs are happy to accept invalid UTF-16, like invalid surrogate pairs). Usually, it&rsquo;s reasonable to just ignore the problem entirely and pretend that it&rsquo;s just UTF-16, but when writing diagnostic tools I think it&rsquo;s important to handle bad data in a way that doesn&rsquo;t hide information or simply fail. Someone could be debugging a problem related to text encoding, and it&rsquo;s important to give users enough information to diagnose the issue.</p><p><sup>2</sup> I&rsquo;m also not completely happy with how it&rsquo;s implemented. I suspect there is a safer, Rust-ier way to do it. You can see the code in <a href=https://github.com/TimMisiak/dbgrs/blob/part3/src/memory.rs>memory.rs</a>. Feel free to give suggestions on how to implement it better.</p></div><div class=post-footer></div></article></main></body></html>