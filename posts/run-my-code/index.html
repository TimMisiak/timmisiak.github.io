<!doctype html><html lang=en-us><head><title>Run My Code! (code injection on Windows) // TimDbg</title>
<link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.121.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Run My Code! (code injection on Windows)"><meta name=twitter:description content="The first time I realized it was possible to get a process to run some extra little code I had written, it felt like the ultimate cheat code. My first attempt was a little patch for Civilization 2 to fix some high CPU usage. Then I discovered that you could inject code at run-time. And when I discovered the ability to change how OS functions worked, it started to feel like I could do anything!"><meta property="og:title" content="Run My Code! (code injection on Windows)"><meta property="og:description" content="The first time I realized it was possible to get a process to run some extra little code I had written, it felt like the ultimate cheat code. My first attempt was a little patch for Civilization 2 to fix some high CPU usage. Then I discovered that you could inject code at run-time. And when I discovered the ability to change how OS functions worked, it started to feel like I could do anything!"><meta property="og:type" content="article"><meta property="og:url" content="/posts/run-my-code/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-27T15:13:28-07:00"><meta property="article:modified_time" content="2023-08-27T15:13:28-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Run My Code! (code injection on Windows)</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Aug 27, 2023</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>8 min read</div></div></header><div class=post-content><p>The first time I realized it was possible to get a process to run some extra little code I had written, it felt like the ultimate cheat code. My first attempt was a little patch for Civilization 2 to fix some high CPU usage. Then I discovered that you could inject code at <em>run-time</em>. And when I discovered the ability to <em>change</em> how OS functions worked, it started to feel like I could do anything!</p><p>Code injection gets used for many purposes, sometimes legitimate, sometimes nefarious. But how do you actually go about injecting code? When most people hear code injection, they think of things like buffer overflow attacks and return oriented programming. These rely on discovering vulnerabilities in some target program. What I often find more interesting are the ways that you can inject code into <em>any</em> process, regardless of security vulnerabilities.</p><p>On Windows, there are a number ways to get code running in a another process, but they all fall into three main categories. Static code injection (patching), DLL injection, and dynamic code injection.</p><h1 id=static-code-injection-patching>Static code injection (Patching)</h1><p>Static code injection is one obvious way to inject code into a process. Just change the executable while it&rsquo;s still on the disk, before it gets a chance to load. If you just need to do a little bit of modification, like patching in a call to a <code>Sleep</code> function in some tight loop, you might even be able to do it manually by using WinDbg to do some patching at runtime, and then figuring out the bytes that need to change in the file.</p><p>This method has some drawbacks. First, you have to actually modify the file on disk, which could be more destructive than you want (e.g. it affects every run of the program, instead of just some instances). Changing the files on disk is also problematic for signed binaries where any changes would invalidate the code signing. And figuring out how to patch binaries in some general way that works for several different versions of a binary is not an easy task.</p><h1 id=dll-injection>DLL injection</h1><p>DLL injection is the most widely used method of injecting code into a process, especially for <em>legitimate</em> code injection. It&rsquo;s popular because the technique is straightforward, and there are a large number of documented mechanisms (with appropriate reasons) for injecting code into processes as a DLL. Just look at all the categories in the <a href=https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns>Sysinternals Autoruns</a> tool. Many of those categories represents some way that code can register itself to be loaded into some or all processes. And that list certainly isn&rsquo;t exhaustive.</p><p>You can also get DLLs to be loaded by using the same name as one that&rsquo;s expected to be there, just earlier in the DLL search order. This is especially easy if the program attempts to load a DLL as a way of checking for some &ldquo;optional&rdquo; functionality. (This is a horrible practice, but believe me that it&rsquo;s everywhere. <a href=https://learn.microsoft.com/en-us/sysinternals/downloads/procmon>Process Monitor</a> can show you all the failed DLL load attempts). For those, all you need is a DLL in the current directory or on the PATH.</p><p>You might assume that DLL injection is more limited than patching, because you can&rsquo;t modify the behavior of the existing code. Combined with the power of <a href=https://github.com/microsoft/Detours>detours</a> to change the behavior of an existing function (such as an OS function, say <code>GetMessageW</code> or <a aria-describedby=footnote-label href=#tickcount><code>GetTickCount64</code></a>), and you now have the ability to drastically alter the behavior of a program!</p><p>Of course, DLL injection has its own set of downsides. It&rsquo;s the frequent source of application compatibility issues. If your DLL loads other DLLs, those DLLs can interfere with the target program. In one case, we got reports of a hardware OEM (of the LED-lit mouse/keyboard variety) that was triggering dbghelp.dll to be loaded into the WinDbg process before WinDbg could load it&rsquo;s <em>own</em> copy of dbghelp.dll, which caused all sorts of havoc. (Also due to the DLL search order, where modules in the loaded module list have precedence even over DLLs in the application directory when calling LoadLibrary!)</p><p>Some apps are also resistant to tampering via DLL injection. Chrome, for instance, has <a href=https://blog.chromium.org/2017/11/reducing-chrome-crashes-caused-by-third.html>some hardening</a> that prevents many forms of DLL injection, as they saw significant stability issues caused by third party injection. Certain Windows processes can also <a href=https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services->be protected</a> when they have some security critical code .</p><h1 id=dynamic-code-injection>Dynamic code injection</h1><p>Dynamic code injection is the trickiest form of code injection, and is generally reserved for nefarious purposes, although you will also see it getting used by diagnostic tools (such as Time Travel Debugging).</p><p>To do dynamic code injection without injecting a DLL, you allocate some memory in the target process using <a href=https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex>AllocVirtualEx</a>, write some bytes representing the code you want to run using <a href=https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory>WriteProcessMemory</a>, and then create a thread (or modify an existing thread) to get the process to run your code. You have to be careful what code you write to the remote process to make sure it can operate independently and not rely on code that <em>isn&rsquo;t</em> copied (or DLLs that are not loaded).</p><p>Let&rsquo;s take a look at an example. Note that this is a simplified example and won&rsquo;t work without careful compilation options. For one, we need to turn off the GS check (/GS-) because it will generate an RIP-relative memory access to data that won&rsquo;t be copied or allocated in the remote process. We&rsquo;ll also build in relase mode but disable optimizations (/Od). Given that, let&rsquo;s start with the payload.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>using</span> MbFunc <span style=color:#f92672>=</span> <span style=color:#66d9ef>decltype</span>(MessageBoxW);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DWORD WINAPI <span style=color:#a6e22e>RemoteFunc</span>(LPVOID lpThreadParameter)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wchar_t</span> sz[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>    sz[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>L</span><span style=color:#e6db74>&#39;H&#39;</span>;
</span></span><span style=display:flex><span>    sz[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>L</span><span style=color:#e6db74>&#39;i&#39;</span>;
</span></span><span style=display:flex><span>    sz[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    MbFunc<span style=color:#f92672>*</span> mb <span style=color:#f92672>=</span> (MbFunc<span style=color:#f92672>*</span>)lpThreadParameter;
</span></span><span style=display:flex><span>    mb(NULL, sz, sz, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function looks really weird, but all it does is call MessageBoxW with the string &ldquo;Hi&rdquo;. It&rsquo;s written in a weird way to make sure it doesn&rsquo;t have any memory accesses outside of the function boundaries. It also takes the address of MessageBoxW as a parameter to avoid a memory access to the import table. We also copy the string in character by character to avoid a memory access to the globals section. This took a little trial and error looking at the code that got generated by the compiler, and it&rsquo;d be pretty painful if you wanted to do anything more complex.</p><p>Now that we have a payload, we need to create a process and inject the code into the process. For that purpose, I&rsquo;m just going to use winver.exe, as it is a simple win32 gui app with a single dialog.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>wchar_t</span> szCmdLine[] <span style=color:#f92672>=</span> <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;winver.exe&#34;</span>;
</span></span><span style=display:flex><span>    STARTUPINFOW si <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    PROCESS_INFORMATION pi <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    si.cb <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(si);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> ret <span style=color:#f92672>=</span> CreateProcessW(NULL, szCmdLine, NULL, NULL, FALSE, <span style=color:#ae81ff>0</span>, NULL, NULL, <span style=color:#f92672>&amp;</span>si, <span style=color:#f92672>&amp;</span>pi);
</span></span></code></pre></div><p>We can allocate some memory in the process using the handle returned:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    LPVOID ptr <span style=color:#f92672>=</span> VirtualAllocEx(pi.hProcess, NULL, <span style=color:#ae81ff>4096</span>, MEM_COMMIT <span style=color:#f92672>|</span> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</span></span></code></pre></div><p>Note that we use PAGE_EXECUTE_READWRITE. That&rsquo;s important! Without the EXECUTE bit, the code would immediately crash. We&rsquo;re allocating 4096 bytes, which will be more than enough memory for our function.</p><p>Now we calculate the size of the data to copy and write it using WriteProcessMemory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> size <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)main <span style=color:#f92672>-</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)RemoteFunc;
</span></span><span style=display:flex><span>    SIZE_T bytesWritten <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> WriteProcessMemory(pi.hProcess, ptr, RemoteFunc, size, <span style=color:#f92672>&amp;</span>bytesWritten);
</span></span></code></pre></div><p>More weird code here. I&rsquo;ve made an assumption that the compiler is going to lay out the <code>RemoteFunc</code> and <code>main</code> functions sequentially. That&rsquo;s a big assumption, but it works here. If you wanted to be more robust, it would be better to put the code in its own segment with the appropriate &ldquo;pragamas&rdquo;, but I&rsquo;m not going to worry about that for this example.</p><p>Finally, we need to actually execute the code. Since our function follows the same signature as LPTHREAD_START_FUNCTION, we can use CreateRemoteThread to start some code running our function. Also, remember that we need to pass in the address of MessageBoxW to the function, so we&rsquo;ll do that too.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> data <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)MessageBoxW;
</span></span><span style=display:flex><span>    HANDLE hthread <span style=color:#f92672>=</span> CreateRemoteThread(pi.hProcess, NULL, <span style=color:#ae81ff>0</span>, (LPTHREAD_START_ROUTINE)ptr, data, <span style=color:#ae81ff>0</span>, NULL);
</span></span></code></pre></div><p>You might be wondering how it&rsquo;s possible that we take the address of MessageBoxW in the local process, but call it in the remote process. This code relies on the fact that MessageBoxW is in user32.dll, which will <a aria-describedby=footnote-label href=#user32>typically be loaded at the same address for all programs</a> (there are cases where this isn&rsquo;t true, but I&rsquo;ll ignore that for the sake of keeping this example simple).</p><p>Run this code and you have remote code injection on the winver.exe process, which you will see by a dialog box that says &ldquo;Hi&rdquo;. And you can confirm that it&rsquo;s part of winver.exe process by closing the winver dialog, which will cause the message box to close as well!</p><h1 id=conclusion>Conclusion</h1><p>Hopefully this gave you some insights about how code injection can work on Windows. But please remember this is for educational purposes, and don&rsquo;t put any of the techniques I mentioned in real production code!</p><p>Have a question or suggestion? Let me know! You can find me on <a href=https://twitter.com/timmisiak>Twitter</a> or <a href=https://dbg.social/@tim>Mastodon</a>.</p><footer><h2 id=footnote-label>Footnotes</h2><ol><li id=tickcount>I once wrote a DLL that intercepted GetTickCount64 and a bunch of similar functions so that it could "stretch time" by some multiplier. It worked surprisingly well in a number of casual games with high score boards. Not that I would ever cheat of course...</li><li id=user32>Originally this post said that user32 is always loaded at the same address, and that was based on what I read in an old <a href="http://www.nynaeve.net/?p=198">nynaeve post</a>, but someone pointed out to me this isn't true anymore (or perhaps never was?). Thanks JCAB!</li></ol></footer></div><div class=post-footer></div></article></main></body></html>