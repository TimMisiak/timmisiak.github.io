<!doctype html><html lang=en-us><head><title>What's the Debugger Data Model? (And Why?) // TimDbg</title>
<link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.121.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="What's the Debugger Data Model? (And Why?)"><meta name=twitter:description content="If you follow me on Twitter, you have probably heard me talk about the &ldquo;Debugger Data Model&rdquo;. But unless you&rsquo;ve spent a bunch of time reading our documentation or you&rsquo;ve read articles such as this one by Yarden Shafir about the Data Model, you might have no idea what I&rsquo;m talking about.
Many of the ways that WinDbg is evolving to be more powerful are through the Debugger Data Model, and understanding it will help you use WinDbg more effectively."><meta property="og:title" content="What's the Debugger Data Model? (And Why?)"><meta property="og:description" content="If you follow me on Twitter, you have probably heard me talk about the &ldquo;Debugger Data Model&rdquo;. But unless you&rsquo;ve spent a bunch of time reading our documentation or you&rsquo;ve read articles such as this one by Yarden Shafir about the Data Model, you might have no idea what I&rsquo;m talking about.
Many of the ways that WinDbg is evolving to be more powerful are through the Debugger Data Model, and understanding it will help you use WinDbg more effectively."><meta property="og:type" content="article"><meta property="og:url" content="/posts/whats-the-data-model/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-30T23:26:09-07:00"><meta property="article:modified_time" content="2022-08-30T23:26:09-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>What's the Debugger Data Model? (And Why?)</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Aug 30, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>8 min read</div></div></header><div class=post-content><p>If you follow <a href=https://twitter.com/timmisiak>me on Twitter</a>, you have probably heard me talk about the &ldquo;Debugger Data Model&rdquo;. But unless you&rsquo;ve spent a bunch of time <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/using-linq-with-the-debugger-objects>reading our documentation</a> or you&rsquo;ve read articles such as <a href=https://medium.com/@yardenshafir2/windbg-the-fun-way-part-1-2e4978791f9b>this one by Yarden Shafir about the Data Model</a>, you might have no idea what I&rsquo;m talking about.</p><p>Many of the ways that WinDbg is evolving to be more powerful are through the Debugger Data Model, and understanding it will help you use WinDbg more effectively. So in this post, I&rsquo;m going to write a bit about what the data model is, and why we made it.</p><h1 id=windbgs-greatest-strength-and-biggest-weakness-extensions>WinDbg&rsquo;s greatest strength and biggest weakness: Extensions</h1><p>If you use WinDbg a lot, then there&rsquo;s a pretty good chance that you&rsquo;ve used some debugger extensions. Extensions are a big part of why WinDbg is so useful. There are hundreds of extension commands that ship with the debugger, and thousands more available. They can do everything from displaying internal kernel structures to inspecting the state of the .NET managed heap. Despite how useful they are, debugger extensions as they have existed for the past few decades have some problems.</p><p><strong>The first problem</strong> is that there are simply too many debugger extensions to find the right ones to use. You can learn about useful extensions from articles, books, coworkers, and documentation, but the debugger is rarely going to tell you the right extension to use for the problem that you&rsquo;re looking at. Hyperlinks between extension commands (what we call <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-markup-language-commands>&ldquo;DML&rdquo;</a>) go a long way towards making it possible to find related extensions. But even with the hyperlinks, you still have to know where to start. In short, traditional debugger extensions are <strong>not discoverable</strong>.</p><p><strong>The second problem</strong> is that the old style of debugger extensions <strong>don&rsquo;t compose because extensions have unstructured output</strong>. In other words, you can&rsquo;t easily use the information in one extension and chain that with another extension. People have written text processing and chaining extensions, but none of these are going to work smoothly with every extension. And since the output is unstructured, it&rsquo;s not something you&rsquo;ll be able to easily use if you want to script the debugger or create a conditional breakpoint.</p><p><strong>The third problem</strong> is that debugger extensions are <strong>incredibly difficult to write</strong>. Extensions are generally written using the <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/dbgeng/nn-dbgeng-idebugclient>DbgEng COM-style API</a> or a wrapper on top of these APIs such as <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/engextcpp-extension-libraries>EngExtCpp</a>. While the APIs available are very powerful, they can also be very clunky and verbose to use, even for some of the simplest things you&rsquo;d want to do in an extension. And the nature of writing a native DLL that uses these APIs often requires lots of boilerplate code.</p><p>Even with all of these problems, extensions have become a huge part of WinDbg&rsquo;s success. So how do we address these problems?</p><h1 id=the-debugger-data-model>The Debugger Data Model</h1><p>Our answer to this was the Debugger Data Model. We wanted to make extensions <strong>easy to discover</strong>, <strong>easy to compose</strong>, and <strong>easy to write</strong>. To do that required a shift in how we think about debugger extensions. The biggest part of that shift is moving from a text model to a structured data model. Creating a system of extensions that work with structured data gives us a path to solve these problems.</p><h1 id=discoverability>Discoverability</h1><p>The best way to make debugger extensions discoverable is to simply make them available when they are needed without having to even know about them in the first place. Previously, to debug any of the C++ Standard Template Library data structures like <code>std::vector</code> you would either need to manually interpret the contents of structures (which could be painful for things like hash tables) or you would need to know about extensions such as <code>!stl</code>. With the debugger data model, the extension for interpreting the STL structures gets used <em>automatically</em> whenever you look at an STL structure.</p><p>Take this code for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>wstring<span style=color:#f92672>&gt;</span> testVec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    testVec.push_back(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;This is the first string&#34;</span>);
</span></span><span style=display:flex><span>    testVec.push_back(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;Here&#39;s string #2&#34;</span>);
</span></span><span style=display:flex><span>    testVec.push_back(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;And our final string!&#34;</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>If we debug this and break in right after the last <code>push_back</code> call, we see something like this when we look at the local variables using the <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/dx--display-visualizer-variables->dx command</a> which evaluates objects using the data model.</p><pre tabindex=0><code>0:000&gt; x
000000b1`f39bf468 testVec = { size=3 }
0:000&gt; dx testVec
testVec                 : { size=3 }
    [&lt;Raw View&gt;]     [Type: std::vector&lt;...&gt;]
...
    [0]              : &#34;This is the first string&#34; 
    [1]              : &#34;Here&#39;s string #2&#34;
    [2]              : &#34;And our final string!&#34;
</code></pre><p>Compare that to what you would see without the debugger data model. The <code>??</code> command does not use the debugger data model for evaluation and visualization by default, so you can use that to see what evaluation would look like without the data model.</p><pre tabindex=0><code>0:000&gt; ?? testVec
class std::vector&lt;std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;,std::allocator&lt;std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;  &gt; &gt;
   +0x000 _Mypair          : std::_Compressed_pair&lt;std::allocator&lt;std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt; &gt;,std::_Vector_val&lt;std::_Simple_types&lt;std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt; &gt; &gt;,1&gt;
</code></pre><p>The difference is that the debugger extension for visualizing STL types is used automatically when you use the data model through <code>dx</code>. You don&rsquo;t need to know that the extension exists. What&rsquo;s more, there are actually two different debugger extensions being used here. One for visualizing the <code>std::vector</code> and another for visualizing the <code>std::wstring</code>. These two extensions work together in a natural way. It doesn&rsquo;t matter that they are both visualizers for STL types. Any extensions such as these will compose in the data model because they describe structured data, instead of simply text output. Which brings us to the next aspect of the debugger data model.</p><h1 id=structured-data-and-composability>Structured data and composability</h1><p>Making extensions in the debugger data model compose together naturally means that the extensions deal with structured data, not text. It opens up new ways of using extensions. For instance, it enables debugger extensions that can be used in <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-a-conditional-breakpoint>conditional breakpoints</a>. It also gives us the ability to write <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/javascript-debugger-scripting>scripts that query data from extensions</a>. And it gives us the ability to <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/dx--display-visualizer-variables->filter, query, and visualize data in a standard way</a>.</p><p>Here&rsquo;s a small test program that we can debug using <code>std::vector</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> testVec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (rand() <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        testVec.push_back(rand());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>100</span>; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        doSomething();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>If we want to set a breakpoint on the doSomething() function so that we break into the debugger only when the testVec structure has 10 items, we can set it with a condition.</p><pre tabindex=0><code>0:000&gt; bp /w &#34;testVec.Count() == 10&#34; doSomething
0:000&gt; g
Breakpoint 0 hit
WindowsConsoleApp!doSomething:
00007ff6`e6476c50 4055            push    rbp
0:000&gt; dx testVec.Count()
testVec.Count()  : 0xa
</code></pre><p>Here we&rsquo;ve created a conditional breakpoint that takes advantage of the extension that understands STL containers in a way that we would never have been able to do with a legacy style extension. Beyond just conditional breakpoints, you can write your own scripts that interact with other extensions and build on them. It&rsquo;s easy enough that it sometimes makes sense to write one-off scripts in cases where you would never dream of writing an old style debugger extension. Which brings us to the last point I want to make.</p><h1 id=ease-of-use>Ease of use</h1><p>A major design goal for the Debugger Data Model was to have a much easier model for writing all sorts of debugger extensions. For that, there are three main ways of writing extensions. The easiest is <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2022">NatVis</a>, which can be used to create visualizations for native objects. NatVis provides a concise way of expressing the logical structure of an native object so that it can be cleanly visualized. For instance, the std::vector visualizer looks something like this in NatVis.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Type</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;std::vector&amp;lt;*&amp;gt;&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;DisplayString&gt;</span>{{size = {_Mylast - _Myfirst}}}<span style=color:#f92672>&lt;/DisplayString&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;Expand&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;Item</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;[size]&#34;</span><span style=color:#f92672>&gt;</span>_Mylast - _Myfirst<span style=color:#f92672>&lt;/Item&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;Item</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;[capacity]&#34;</span><span style=color:#f92672>&gt;</span>(_Myend - _Myfirst)<span style=color:#f92672>&lt;/Item&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;ArrayItems&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;Size&gt;</span>_Mylast - _Myfirst<span style=color:#f92672>&lt;/Size&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;ValuePointer&gt;</span>_Myfirst<span style=color:#f92672>&lt;/ValuePointer&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/ArrayItems&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/Expand&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/Type&gt;</span></span></span></code></pre></div><p>NatVis has a number of advantages, including the ability to be embedded in a PDB, and support in both WinDbg and Visual Studio. You can edit <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/windbg-scripting-preview>NatVis files directly in WinDbg</a> in a very streamlined workflow.</p><p>NatVis will always be my first choice when writing visualizations. If NatVis isn&rsquo;t expressive enough, or if you want to write a debugger extension that does more than just interpret a native structure, you can write an extension in JavaScript. For instance, if you are debugging some code with a vector of structures like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>foo</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> iVal;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> bVal;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>foo<span style=color:#f92672>&gt;</span> testVec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    testVec.push_back(foo{ <span style=color:#ae81ff>5</span>, false });
</span></span><span style=display:flex><span>    testVec.push_back(foo{ <span style=color:#ae81ff>100</span>, true });
</span></span><span style=display:flex><span>    testVec.push_back(foo{ <span style=color:#ae81ff>20</span>, false });
</span></span><span style=display:flex><span>    testVec.push_back(foo{ <span style=color:#ae81ff>30</span>, true });
</span></span><span style=display:flex><span>    testVec.push_back(foo{ <span style=color:#ae81ff>1</span>, true });
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>You can write a script that access this data as simply as this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>findSumOfTrueItems</span>(<span style=color:#a6e22e>vec</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sum</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>item</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>vec</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>bVal</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>iVal</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>You can use this JavaScript function easily in the data model.</p><pre tabindex=0><code>0:000&gt; dx @$scriptContents.findSumOfTrueItems(testVec)
@$scriptContents.findSumOfTrueItems(testVec) : 0x83
</code></pre><p>In this example, you can see that the script works with other extensions. The NatVis visualizer lets the debugger bring the <code>std::vector</code> object into the JavaScript environment seamlessly. The individual members are native objects, and also get projected into JavaScript, making it very easy to access data of the target that is being debugged. It&rsquo;s simple and concise. And it doesn&rsquo;t stop with just native objects. You can also write extensions that add information to concepts such as processes, threads, and stack frames, adding data to queries like <code>dx @$curprocess</code> or <code>dx @$curstack.Frames</code>.</p><p>Going into more depth than this would make this post way too long, but if you want to learn more, you can take a look at the <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/javascript-debugger-scripting>documentation</a> as well as our <a href=https://github.com/microsoft/WinDbg-Samples/tree/master/DataModelHelloWorld>samples</a>, which include both JavaScript and C++ data model extensions.</p><h1 id=conclusion>Conclusion</h1><p>Even without going into much depth, this post has gotten long. There&rsquo;s a lot more I could say here, and I&rsquo;m sure I&rsquo;ll write more about specific aspects of the data model. We still have lots of plans for how to make the debugger data model easier to use and more powerful, and I don&rsquo;t think we&rsquo;ve even scratched the surface of what it can become.</p><p>What else do you want to know about the data model? Have any scripts or queries that you think are cool? Let me know what you think on <a href=https://twitter.com/timmisiak/status/1564991866432811008>Twitter</a>!</p></div><div class=post-footer></div></article></main></body></html>