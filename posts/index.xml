<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on TimDbg</title><link>/posts/</link><description>Recent content in Posts on TimDbg</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2022 Tim Misiak</copyright><lastBuildDate>Mon, 06 Mar 2023 08:44:39 -0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing a Debugger From Scratch - DbgRs Part 2 - Register State and Stepping</title><link>/posts/writing-a-debugger-from-scratch-part-2/</link><pubDate>Mon, 06 Mar 2023 08:44:39 -0800</pubDate><guid>/posts/writing-a-debugger-from-scratch-part-2/</guid><description>When we left off last time, we had a basic &amp;ldquo;debugger&amp;rdquo; that could launch a Windows process and monitor events that occur in that process, but it&amp;rsquo;s not yet something that you would really call a debugger. Two things that are missing are the ability to examine the state of the process and to control its execution. So that&amp;rsquo;s what we&amp;rsquo;re going to build next.
The code for this part is on GitHub as the part2 branch.</description></item><item><title>Writing a Debugger From Scratch - DbgRs Part 1</title><link>/posts/writing-a-debugger-from-scratch-part-1/</link><pubDate>Mon, 13 Feb 2023 09:20:24 -0700</pubDate><guid>/posts/writing-a-debugger-from-scratch-part-1/</guid><description>I&amp;rsquo;ve left the Microsoft Debugger Platform team twice, and each time I&amp;rsquo;ve started writing my own debugger. I must really like debuggers or something. This time, I have two reasons for writing a new debugger. The first is because I want to learn Rust better, and writing something I already understand pretty well seems like a good way to learn. The second reason is to make it easier for people to learn how a debugger works.</description></item><item><title>Weird things I learned while writing an x86 emulator</title><link>/posts/useless-x86-trivia/</link><pubDate>Wed, 01 Feb 2023 23:54:20 -0800</pubDate><guid>/posts/useless-x86-trivia/</guid><description>If you&amp;rsquo;ve read my first post about assembly language, you might expect that this is another post on how to understand assembly language. I will write more about that at some point, but this post is not that. Instead, this post is going to talk about some of the weird things and random trivia I learned while writing an x86 and amd64 emulator. The emulator I wrote was for Time Travel Debugging.</description></item><item><title>The faker's guide to reading (x86) assembly language</title><link>/posts/fakers-guide-to-assembly/</link><pubDate>Tue, 03 Jan 2023 09:20:24 -0700</pubDate><guid>/posts/fakers-guide-to-assembly/</guid><description>Assembly code scares people. There&amp;rsquo;s a good reason for that. For many people, writing code in assembly language seems equivalent to writing code in ancient dwarven runes, or calculating pi in roman numerals. The fact that Roller Coast Tycoon was almost completely written in assembly language sounds almost too amazing to be true. Many programmers view assembly language as some combination of ancient, arcane, inscrutable, useless, and complex.
Despite all that, I have a secret to share with you.</description></item><item><title>What's a vtable? What's an IUnknown?</title><link>/posts/vtables/</link><pubDate>Sun, 18 Dec 2022 08:30:09 -0700</pubDate><guid>/posts/vtables/</guid><description>Understanding vtables (also called VMT/Virtual Method Tables or VFT/Virtual Function Tables) is important for understanding how many C++ features work on any OS. They are even more important to understand on Windows, where vtables are used for communication between modules using COM. There are a few types of errors that can happen when things go wrong with them, and some of these will be extremely difficult to diagnose unless you understand how vtables actually work.</description></item><item><title>Recognizing patterns in memory</title><link>/posts/recognizing-patterns/</link><pubDate>Thu, 24 Nov 2022 08:30:09 -0700</pubDate><guid>/posts/recognizing-patterns/</guid><description>Something I find frustrating is how hard it is to teach debugging skills. I think the biggest reason is because there are many things that can only be learned through experience. This is true for anything that requires pattern recognition. Our brains are great at recognizing patterns, but it often takes a large amount of practice to be able to identify useful patterns in data.
I can&amp;rsquo;t instantly give you pattern recognition skills with a short blog post, but I can tell you about some of the patterns that I look for so you can start to train your brain to see these as well.</description></item><item><title>What's the Target Model? (And Why?)</title><link>/posts/whats-the-target-model/</link><pubDate>Mon, 03 Oct 2022 09:54:07 -0700</pubDate><guid>/posts/whats-the-target-model/</guid><description>How do you teach an old dog new tricks? That&amp;rsquo;s the topic of today&amp;rsquo;s post. &amp;ldquo;WinDbg&amp;rdquo; is short for &amp;ldquo;Windows Debugger&amp;rdquo;, but lately that name seems a bit odd since the WinDbg of today knows about a lot more than just Windows. WinDbg now supports Linux and MacOS crash dump targets, as well as few things that are a bit of a hybrid, like Open Enclave debugging.
The core &amp;ldquo;debug engine&amp;rdquo; behind WinDbg is called &amp;ldquo;DbgEng&amp;rdquo;, and it&amp;rsquo;s been a Windows-centric debugging engine for decades.</description></item><item><title>Why you should do printf debugging</title><link>/posts/why-you-should-printf/</link><pubDate>Sat, 24 Sep 2022 12:20:24 -0700</pubDate><guid>/posts/why-you-should-printf/</guid><description>If you know who I am, you might think that this post title is clickbait. Maybe it is, a little. But the truth is, you should do printf debugging! Sometimes. Often not. But sometimes, you should!
Let me explain. When most of us first started programming, we had one tool at our disposal. It was &amp;ldquo;printf debugging&amp;rdquo;. Sometimes just littering the code with printf(&amp;quot;here&amp;quot;), printf(&amp;quot;here2&amp;quot;), and my favorite, printf(&amp;quot;why won't this code work?</description></item><item><title>What's the Debugger Data Model? (And Why?)</title><link>/posts/whats-the-data-model/</link><pubDate>Tue, 30 Aug 2022 23:26:09 -0700</pubDate><guid>/posts/whats-the-data-model/</guid><description>If you follow me on Twitter, you have probably heard me talk about the &amp;ldquo;Debugger Data Model&amp;rdquo;. But unless you&amp;rsquo;ve spent a bunch of time reading our documentation or you&amp;rsquo;ve read articles such as this one by Yarden Shafir about the Data Model, you might have no idea what I&amp;rsquo;m talking about.
Many of the ways that WinDbg is evolving to be more powerful are through the Debugger Data Model, and understanding it will help you use WinDbg more effectively.</description></item><item><title>Debugger Lies: Stack Corruption</title><link>/posts/debugger-lies-part-1/</link><pubDate>Sun, 21 Aug 2022 09:57:31 -0700</pubDate><guid>/posts/debugger-lies-part-1/</guid><description>There are lots of reasons your debugger might be lying to you. Sometimes it&amp;rsquo;s because information is lost when compiling due to optimizations. Sometimes the symbolic debug information isn&amp;rsquo;t expressive enough. Other times it can be due to a bug in the debugger (although I hope that reason is rare). One frustrating case where the debugger sometimes &amp;ldquo;lies&amp;rdquo; to you is the stack walk. It&amp;rsquo;s the single most important piece of information to come out of a crash, so when the stack walk is wrong, it&amp;rsquo;s probably going to make analysis difficult.</description></item><item><title>Symbol and Binary Indexing</title><link>/posts/symbol-indexing/</link><pubDate>Wed, 10 Aug 2022 08:30:09 -0700</pubDate><guid>/posts/symbol-indexing/</guid><description>Symbol indexing is one of those features of WinDbg that can make things &amp;ldquo;just work&amp;rdquo; in a way that seems like magic. But it can also be the most painful things when it goes wrong.
Why should I index symbols and binaries? Most of us have tried to debug without symbols at one point, and it can quickly become an exercise in frustration. It&amp;rsquo;s much more productive to debug an executable where you have symbols because it gives you function names, variable names, type definitions, and source files.</description></item><item><title>Remote Debugging</title><link>/posts/remote-debugging/</link><pubDate>Fri, 05 Aug 2022 00:52:15 -0700</pubDate><guid>/posts/remote-debugging/</guid><description>A key feature of WinDbg and NTSD is the ability to debug a target &amp;ldquo;remotely&amp;rdquo; from a separate computer. For kernel debugging, this is often the only way to debug, since the entire OS is &amp;ldquo;frozen&amp;rdquo; when broken into a kernel debugger. Remote debugging is also available for usermode debugging, and is often just as useful. Sometimes it&amp;rsquo;s useful because the target that you are testing on is different from the one you are using for development.</description></item><item><title>My new blog</title><link>/posts/first-post/</link><pubDate>Thu, 04 Aug 2022 11:15:04 -0700</pubDate><guid>/posts/first-post/</guid><description>Hi everyone! Since I started tweeting about WinDbg and debugging, I&amp;rsquo;ve been thinking about some longer things I want to write that don&amp;rsquo;t really fit on twitter. I&amp;rsquo;ve done a few of these as videos on my YouTube channel, but those are time consuming to make and most people don&amp;rsquo;t seem to watch the whole video. So I think a lot of what I want to talk about is probably best suited for a blog format.</description></item></channel></rss>