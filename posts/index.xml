<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on TimDbg</title><link>/posts/</link><description>Recent content in Posts on TimDbg</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 30 Aug 2022 23:26:09 -0700</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>What's the Debugger Data Model? (And Why?)</title><link>/posts/whats-the-data-model/</link><pubDate>Tue, 30 Aug 2022 23:26:09 -0700</pubDate><guid>/posts/whats-the-data-model/</guid><description>If you follow me on Twitter, you have probably heard me talk about the &amp;ldquo;Debugger Data Model&amp;rdquo;. But unless you&amp;rsquo;ve spent a bunch of time reading our documentation or you&amp;rsquo;ve read articles such as this one by Yarden Shafir about the Data Model, you might have no idea what I&amp;rsquo;m talking about.
Many of the ways that WinDbg is evolving to be more powerful are through the Debugger Data Model, and understanding it will help you use WinDbg more effectively.</description></item><item><title>Debugger Lies: Stack Corruption</title><link>/posts/debugger-lies-part-1/</link><pubDate>Sun, 21 Aug 2022 09:57:31 -0700</pubDate><guid>/posts/debugger-lies-part-1/</guid><description>There are lots of reasons your debugger might be lying to you. Sometimes it&amp;rsquo;s because information is lost when compiling due to optimizations. Sometimes the symbolic debug information isn&amp;rsquo;t expressive enough. Other times it can be due to a bug in the debugger (although I hope that reason is rare). One frustrating case where the debugger sometimes &amp;ldquo;lies&amp;rdquo; to you is the stack walk. It&amp;rsquo;s the single most important piece of information to come out of a crash, so when the stack walk is wrong, it&amp;rsquo;s probably going to make analysis difficult.</description></item><item><title>Symbol and Binary Indexing</title><link>/posts/symbol-indexing/</link><pubDate>Wed, 10 Aug 2022 08:30:09 -0700</pubDate><guid>/posts/symbol-indexing/</guid><description>Symbol indexing is one of those features of WinDbg that can make things &amp;ldquo;just work&amp;rdquo; in a way that seems like magic. But it can also be the most painful things when it goes wrong.
Why should I index symbols and binaries? Most of us have tried to debug without symbols at one point, and it can quickly become an exercise in frustration. It&amp;rsquo;s much more productive to debug an executable where you have symbols because it gives you function names, variable names, type definitions, and source files.</description></item><item><title>Remote Debugging</title><link>/posts/remote-debugging/</link><pubDate>Fri, 05 Aug 2022 00:52:15 -0700</pubDate><guid>/posts/remote-debugging/</guid><description>A key feature of WinDbg and NTSD is the ability to debug a target &amp;ldquo;remotely&amp;rdquo; from a separate computer. For kernel debugging, this is often the only way to debug, since the entire OS is &amp;ldquo;frozen&amp;rdquo; when broken into a kernel debugger. Remote debugging is also available for usermode debugging, and is often just as useful. Sometimes it&amp;rsquo;s useful because the target that you are testing on is different from the one you are using for development.</description></item><item><title>My new blog</title><link>/posts/first-post/</link><pubDate>Thu, 04 Aug 2022 11:15:04 -0700</pubDate><guid>/posts/first-post/</guid><description>Hi everyone! Since I started tweeting about WinDbg and debugging, I&amp;rsquo;ve been thinking about some longer things I want to write that don&amp;rsquo;t really fit on twitter. I&amp;rsquo;ve done a few of these as videos on my YouTube channel, but those are time consuming to make and most people don&amp;rsquo;t seem to watch the whole video. So I think a lot of what I want to talk about is probably best suited for a blog format.</description></item></channel></rss>