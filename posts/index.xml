<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on TimDbg</title><link>/posts/</link><description>Recent content in Posts on TimDbg</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Oct 2022 09:54:07 -0700</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>What's the Target Model? (And Why?)</title><link>/posts/whats-the-target-model/</link><pubDate>Mon, 03 Oct 2022 09:54:07 -0700</pubDate><guid>/posts/whats-the-target-model/</guid><description>How do you teach an old dog new tricks? That&amp;rsquo;s the topic of today&amp;rsquo;s post. &amp;ldquo;WinDbg&amp;rdquo; is short for &amp;ldquo;Windows Debugger&amp;rdquo;, but lately that name seems a bit odd since the WinDbg of today knows about a lot more than just Windows. WinDbg now supports Linux and MacOS crash dump targets, as well as few things that are a bit of a hybrid, like Open Enclave debugging.
The core &amp;ldquo;debug engine&amp;rdquo; behind WinDbg is called &amp;ldquo;DbgEng&amp;rdquo;, and it&amp;rsquo;s been a Windows-centric debugging engine for decades.</description></item><item><title>Why you should do printf debugging</title><link>/posts/why-you-should-printf/</link><pubDate>Sat, 24 Sep 2022 12:20:24 -0700</pubDate><guid>/posts/why-you-should-printf/</guid><description>If you know who I am, you might think that this post title is clickbait. Maybe it is, a little. But the truth is, you should do printf debugging! Sometimes. Often not. But sometimes, you should!
Let me explain. When most of us first started programming, we had one tool at our disposal. It was &amp;ldquo;printf debugging&amp;rdquo;. Sometimes just littering the code with printf(&amp;quot;here&amp;quot;), printf(&amp;quot;here2&amp;quot;), and my favorite, printf(&amp;quot;why won't this code work?</description></item><item><title>What's the Debugger Data Model? (And Why?)</title><link>/posts/whats-the-data-model/</link><pubDate>Tue, 30 Aug 2022 23:26:09 -0700</pubDate><guid>/posts/whats-the-data-model/</guid><description>If you follow me on Twitter, you have probably heard me talk about the &amp;ldquo;Debugger Data Model&amp;rdquo;. But unless you&amp;rsquo;ve spent a bunch of time reading our documentation or you&amp;rsquo;ve read articles such as this one by Yarden Shafir about the Data Model, you might have no idea what I&amp;rsquo;m talking about.
Many of the ways that WinDbg is evolving to be more powerful are through the Debugger Data Model, and understanding it will help you use WinDbg more effectively.</description></item><item><title>Debugger Lies: Stack Corruption</title><link>/posts/debugger-lies-part-1/</link><pubDate>Sun, 21 Aug 2022 09:57:31 -0700</pubDate><guid>/posts/debugger-lies-part-1/</guid><description>There are lots of reasons your debugger might be lying to you. Sometimes it&amp;rsquo;s because information is lost when compiling due to optimizations. Sometimes the symbolic debug information isn&amp;rsquo;t expressive enough. Other times it can be due to a bug in the debugger (although I hope that reason is rare). One frustrating case where the debugger sometimes &amp;ldquo;lies&amp;rdquo; to you is the stack walk. It&amp;rsquo;s the single most important piece of information to come out of a crash, so when the stack walk is wrong, it&amp;rsquo;s probably going to make analysis difficult.</description></item><item><title>Symbol and Binary Indexing</title><link>/posts/symbol-indexing/</link><pubDate>Wed, 10 Aug 2022 08:30:09 -0700</pubDate><guid>/posts/symbol-indexing/</guid><description>Symbol indexing is one of those features of WinDbg that can make things &amp;ldquo;just work&amp;rdquo; in a way that seems like magic. But it can also be the most painful things when it goes wrong.
Why should I index symbols and binaries? Most of us have tried to debug without symbols at one point, and it can quickly become an exercise in frustration. It&amp;rsquo;s much more productive to debug an executable where you have symbols because it gives you function names, variable names, type definitions, and source files.</description></item><item><title>Remote Debugging</title><link>/posts/remote-debugging/</link><pubDate>Fri, 05 Aug 2022 00:52:15 -0700</pubDate><guid>/posts/remote-debugging/</guid><description>A key feature of WinDbg and NTSD is the ability to debug a target &amp;ldquo;remotely&amp;rdquo; from a separate computer. For kernel debugging, this is often the only way to debug, since the entire OS is &amp;ldquo;frozen&amp;rdquo; when broken into a kernel debugger. Remote debugging is also available for usermode debugging, and is often just as useful. Sometimes it&amp;rsquo;s useful because the target that you are testing on is different from the one you are using for development.</description></item><item><title>My new blog</title><link>/posts/first-post/</link><pubDate>Thu, 04 Aug 2022 11:15:04 -0700</pubDate><guid>/posts/first-post/</guid><description>Hi everyone! Since I started tweeting about WinDbg and debugging, I&amp;rsquo;ve been thinking about some longer things I want to write that don&amp;rsquo;t really fit on twitter. I&amp;rsquo;ve done a few of these as videos on my YouTube channel, but those are time consuming to make and most people don&amp;rsquo;t seem to watch the whole video. So I think a lot of what I want to talk about is probably best suited for a blog format.</description></item></channel></rss>