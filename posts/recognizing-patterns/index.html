<!doctype html><html lang=en-us><head><title>Recognizing patterns in memory // TimDbg</title><link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Recognizing patterns in memory"><meta name=twitter:description content="Something I find frustrating is how hard it is to teach debugging skills. I think the biggest reason is because there are many things that can only be learned through experience. This is true for anything that requires pattern recognition. Our brains are great at recognizing patterns, but it often takes a large amount of practice to be able to identify useful patterns in data.
I can&rsquo;t instantly give you pattern recognition skills with a short blog post, but I can tell you about some of the patterns that I look for so you can start to train your brain to see these as well."><meta property="og:title" content="Recognizing patterns in memory"><meta property="og:description" content="Something I find frustrating is how hard it is to teach debugging skills. I think the biggest reason is because there are many things that can only be learned through experience. This is true for anything that requires pattern recognition. Our brains are great at recognizing patterns, but it often takes a large amount of practice to be able to identify useful patterns in data.
I can&rsquo;t instantly give you pattern recognition skills with a short blog post, but I can tell you about some of the patterns that I look for so you can start to train your brain to see these as well."><meta property="og:type" content="article"><meta property="og:url" content="/posts/recognizing-patterns/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-24T08:30:09-07:00"><meta property="article:modified_time" content="2022-11-24T08:30:09-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. Windows debugging tips from a WinDbg dev</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Recognizing patterns in memory</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Nov 24, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>10 min read</div></div></header><div class=post-content><p>Something I find frustrating is how hard it is to teach debugging skills. I think the biggest reason is because there are many things that can only be learned through experience. This is true for anything that requires pattern recognition. Our brains are great at recognizing patterns, but it often takes a large amount of practice to be able to identify useful patterns in data.</p><p>I can&rsquo;t instantly give you pattern recognition skills with a short blog post, but I can tell you about some of the patterns that I look for so you can start to train your brain to see these as well. Recognizing patterns in memory can be useful as it can give you a hint for things like memory corruption, which are often some of the hardest errors to debug from a postmortem analysis. Getting a rough idea of what type data is ovewriting other data in a process can tell you where to look next for the source of memory corruption. It can help narrow down where an issue might be because the bug is usually near the code that wrote this data.</p><h1 id=aligned-3264-bit-data>Aligned 32/64-bit data</h1><p>A frequent pattern in both file formats and in-memory data structures is aligned 32-bit or 64-bit data. We often choose to use 32-bits for values that will never come close to filling the full space. Additionally, even when smaller data types are used, it&rsquo;s common for these values to be aligned to 32-bit or 64-bit boundaries. In both cases, we see distinct patterns when most of the data is much smaller than the reserved space.</p><p>Take this memory dump for example:</p><pre tabindex=0><code>09 00 00 00 30 43 00 00 0A 55 02 00 10 00 00 00
E0 49 01 00 2A 0B 01 00 06 00 00 00 A8 00 00 00
78 06 00 00 07 00 00 00 38 00 00 00 EC 00 00 00
0F 00 00 00 54 05 00 00 24 01 00 00 0C 00 00 00
F8 3A 00 00 32 D0 00 00 15 00 00 00 EC 01 00 00
A4 2A 00 00 16 00 00 00 98 00 00 00 90 2C 00 00
</code></pre><p>When viewing the data as 8 bytes or 16 bytes per line, columns show up with similar types of data. Column 0 is the least significant byte of a 4-byte field, and is all non-zero. Column 3 is most significant byte, and is all zeros because none of the values are larger than 24 bits. You can see a similar pattern across the other columns repeating every 4 bytes, so we can say with high confidence that there are a bunch of 32-bit values here.</p><h2 id=pointers>Pointers</h2><p>A special case of aligned data is pointers. These are often very easy to spot. While a 64-bit pointer could span the entire address range, in reality they exist in a limited part of the address space in windows usermode processes. The virtual address space is <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/virtual-address-spaces>the 128-terabyte range 0x0000'00000000 through 0x7FFF&rsquo;FFFFFFFF</a>. As a result, one easy way to see if 64-bit value might be a pointer is checking if the high 16 bits are all zero. (e.g. in the form of <code>0x0000XXXX'XXXXXXXX</code>). To make things easier, the allocated virtual memory tends to be &ldquo;clumped together&rdquo; in a few clusters for most processes.</p><p>Take this stack dump for instance:</p><pre tabindex=0><code>0:000&gt; dp @rsp
000000d3`f213ef00  00000000`00000000 000000d3`f213ef90
000000d3`f213ef10  00000000`00000000 000000d3`f213ef90
000000d3`f213ef20  00000000`00000000 00000000`00000040
000000d3`f213ef30  00000000`00000010 00007ffc`690e3ff5
000000d3`f213ef40  00007ffc`69135a00 00007ffc`69135900
000000d3`f213ef50  00007ffc`69135900 00007ffc`69135900
000000d3`f213ef60  000000d3`f213f034 00007ffc`00000004
000000d3`f213ef70  00000000`00000000 00000000`00000000
</code></pre><p>You can see two patterns that stand out. There are a few 64-bit values that start with <code>00007ffc</code>, and a few that start with <code>000000d3</code>. The ones that start with <code>d3</code> are stack addresses, and you can see that from the fact that RSP starts with <code>d3</code> as well. (cross-thread stack references are rare, but stacks will often start with the same 32-bits). The <code>00007fXX</code> sequence is also very common, and is usually loaded modules. The stack and heap addresses are somewhat random, but unless an application has high memory consumption, there will probably be only a few of these that are valid within a process. You can see this by running <code>!address</code> in a process with no parameters.</p><p>The nice part is that if something &ldquo;looks like&rdquo; an address, it&rsquo;s very easy to check if it actually is a valid address. Just run <code>!address &lt;address></code>, which will tell you if the address is valid in the current process. The odds of a 64-bit value being a pointer by chance is quite low.</p><p>Other useful commands to use with an arbitrary address include <code>ln</code> to find the closest symbol (for addresess inside a module) and <code>!heap</code> to find information about a heap allocation.</p><h1 id=utf-16-characters>UTF-16 characters</h1><p>A common text encoding in Windows is UTF-16. This is usually very easy to recognize since most hex viewers will show you the ASCII representation of data, and UTF-16 encoding will usually look like ascii characters with &ldquo;blank characters&rdquo; every other byte, like this:</p><pre tabindex=0><code>..C.:.\.P.r.o.g.
r.a.m. .F.i.l.e.
s.\.W.i.n.d.o.w.
</code></pre><p>Obviously UTF-16 could look much different if they were for localized strings in other languages, but it&rsquo;s still very common to see strings where the characters are in the range of 0-127, where the interpretation overlap with the ASCII interpretation. (As a side note, I&rsquo;ll mention that no matter how careful you are, you will always find someone who thinks you have used the incorrect terminology when it comes to text encoding)</p><p>If you are viewing just hex bytes, it&rsquo;s nearly as easy to recognize:</p><pre tabindex=0><code>00 00 43 00 3A 00 5C 00 50 00 72 00 6F 00 67 00
72 00 61 00 6D 00 20 00 46 00 69 00 6C 00 65 00
73 00 5C 00 57 00 69 00 6E 00 64 00 6F 00 77 00
</code></pre><p>Every other column will be full of zeros, and the other columns will generally be 20-7F.</p><h1 id=code-bytes>Code bytes</h1><p>Each architecture is a bit different in the way that instructions are encoded. Most of my experience is with x86 and x64 code. It tends to be very easy to spot &ldquo;normal&rdquo; code that was generated by a compiler. Hand coded assembly can sometimes be harder to spot.</p><p>There are a few tricks to spotting x64 code quickly. Take this data for instance:</p><pre tabindex=0><code>F0 01 00 00 5B C3 CC CC CC CC CC CC CC CC CC CC
48 83 EC 38 48 83 64 24 20 00 41 B9 01 00 00 00
4C 8D 44 24 40 41 8D 51 10 48 C7 C1 FE FF FF FF
E8 0B CC FC FF 85 C0 78 0A 80 7C 24 40 00 75 03
CC EB 00 48 83 C4 38 C3 CC CC CC CC CC CC CC CC
</code></pre><p>The first thing you&rsquo;ll notice is the lack of alignment. X86 uses a variable length encoding, and there is generally not a reason to align code on 32-bit or 64-bit boundaries inside a function (although there is a reason to have 32-bit aligned addresses as the <em>start</em> of a function or other jump target). The second thing you will notice is the abundance of <code>CC</code> bytes. This is the one byte encoding for the <code>int 3</code> instruction, which is the instruction used to trigger a software breakpoint. These are sometimes inserted in between functions to align the entry address of the next function. Using <code>CC</code> bytes means a misjump to these locations will trigger an immediate breakpoint exception instead of accidentally running some arbitrary part of code. So you&rsquo;ll see these sequences of <code>CC</code> bytes, and they will always end at some aligned address. The other thing to notice about these sequences is that they usually start with a <code>C3</code> byte, which is single byte encoding for a <code>ret</code> instruction, which is very frequently (but not always) the last instruction of a function.</p><p>These tricks work very well for binaries that are part of Windows, as the compiler options used means these sequences will nearly always show up. Other compilers and compiler options won&rsquo;t have these. Or you may be looking at a small part of a larger function. For this, there are some other tricks I use. Take this code for instance:</p><pre tabindex=0><code>41 54 55 57 56 53 48 83 EC 20 48 8B 35 CF 73 1F
00 85 D2 48 89 CF 89 D3 4C 89 C5 89 16 75 54 8B
05 5B 1D 21 00 85 C0 74 33 E8 A2 52 17 00 49 89
E8 31 D2 48 89 F9 E8 75 63 17 00 49 89 E8 89 DA
</code></pre><p>Two patterns I&rsquo;ll direct your attention to. The first is the sequence <code>54 55 57 56 53</code>. It doesn&rsquo;t look completely random, and in fact there is a reason why there are a bunch of bytes in the 50-57 range. These are all single byte &ldquo;push&rdquo; instructions. In fact, anything starting with a 5 is either a push or a pop instruction. These often show up in a sequence because push and pop instructions can be found clustered at the start and end of a function. The other thing to notice is that there are a bunch of <code>4X</code> bytes in this sequence. These are very common in x64 code because they are a prefix byte used to access the larger register set available in x64 compared to x86 (called the REX prefix). It&rsquo;s possible to see a <code>4X</code> byte in the middle of an instruction and not acting as a prefix, of course, but more often than not this will mark the beginning of an instruction. If you see a <code>4X</code> byte followed by an <code>8X</code> byte, it&rsquo;s very likely a basic ALU operation or <code>MOV</code> operation. These represent a very large percent of most code. Just look through disassembly for any function and you will likely see a lot of <code>8X</code> or <code>4X 8X</code> sequences at the start of instructions.</p><p>You can always use a disassembler to test this theory and see if the instructions &ldquo;look&rdquo; right, but determining what looks right would could be a blog post of its own.</p><h1 id=high-entropy-data>High entropy data</h1><p>If you have something that doesn&rsquo;t show any obvious signs of alignment, and doesn&rsquo;t have any executable code, it&rsquo;s possible that you&rsquo;re looking at some high entropy data. Take this sequence:</p><pre tabindex=0><code>02 4D 1C 07 18 CF 3F 2B F4 B0 50 F8 D9 6E 1D 91
83 4E DF 75 D0 BE B2 D2 9F AC 79 18 C4 67 A5 A0
47 04 EF F4 85 A0 53 8C 52 90 84 4C B7 22 4B C5
</code></pre><p>Here we see no obvious alignment, no sequences of <code>CC</code>, no occurrences of <code>C3</code>, and no sequences of <code>4X 8X</code>. High entropy data could be any number of things, but it almost always falls into one of two categories:</p><ol><li>Compressed data</li><li>Encrypted data</li></ol><p>Without more context, it&rsquo;s generally not possible to identify the format of high entropy data or even to determine if a sequence of bytes is compressed or encrypted. There are probably some cases where you can find some data structures embedded for compressed data (like data about video frames for instance), but given that the compressed portion will usually be larger than the fixed layout structures, it will usually take more work to find. The best bet here is to try to find a header for the data, and see if there is some signature that tells you more. But if there&rsquo;s just a small snippet of high entropy data corrupting some other memory, you may want to consider what sort of high entropy data the application could be dealing with (could it be decompressing data? transmitting encrypted data over a network?)</p><h1 id=conclusion>Conclusion</h1><p>The idea of recognizing a sequences of bytes and finding the meaning behind them has always felt very satisfying to me. Have you ever found this useful? Do you have any tricks of your own? Let me know on <a href=https://twitter.com/timmisiak>Twitter</a> or <a href=https://dbg.social/@tim>Mastodon</a>!</p></div><div class=post-footer></div></article></main></body></html>