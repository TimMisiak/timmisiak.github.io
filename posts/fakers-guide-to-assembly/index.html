<!doctype html><html lang=en-us><head><title>The faker's guide to reading (x86) assembly language // TimDbg</title>
<link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.125.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX")}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="The faker's guide to reading (x86) assembly language"><meta name=twitter:description content="Assembly code scares people. There&rsquo;s a good reason for that. For many people, writing code in assembly language seems equivalent to writing code in ancient dwarven runes, or calculating pi in roman numerals. The fact that Roller Coast Tycoon was almost completely written in assembly language sounds almost too amazing to be true. Many programmers view assembly language as some combination of ancient, arcane, inscrutable, useless, and complex.
Despite all that, I have a secret to share with you."><meta property="og:url" content="/posts/fakers-guide-to-assembly/"><meta property="og:site_name" content="TimDbg"><meta property="og:title" content="The faker's guide to reading (x86) assembly language"><meta property="og:description" content="Assembly code scares people. There&amp;rsquo;s a good reason for that. For many people, writing code in assembly language seems equivalent to writing code in ancient dwarven runes, or calculating pi in roman numerals. The fact that Roller Coast Tycoon was almost completely written in assembly language sounds almost too amazing to be true. Many programmers view assembly language as some combination of ancient, arcane, inscrutable, useless, and complex.
Despite all that, I have a secret to share with you."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-03T09:20:24-07:00"><meta property="article:modified_time" content="2023-01-03T09:20:24-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>The faker's guide to reading (x86) assembly language</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Jan 3, 2023</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
14 min read</div></div></header><div class=post-content><p>Assembly code scares people. There&rsquo;s a good reason for that. For many people, writing code in assembly language seems equivalent to writing code in ancient dwarven runes, or calculating pi in roman numerals. The fact that Roller Coast Tycoon was <a href=http://www.chrissawyergames.com/faq3.htm>almost completely written in assembly language</a> sounds almost too amazing to be true. Many programmers view assembly language as some combination of ancient, arcane, inscrutable, useless, and complex.</p><p>Despite all that, I have a secret to share with you. Reading assembly language is not really that hard. Or at the very least, it&rsquo;s an order of magnitude easier than <em>writing</em> assembly language. There are a few reasons why that&rsquo;s true, but before we dive into that, let me first tell you why you should care about assembly language.</p><h1 id=why-should-i-care>Why should I care?</h1><p>For most people that write in languages that compile to native code, assembly language represents the fundamental building blocks for every program that we build and run<sup>1</sup>. If you&rsquo;ve ever had to troubleshoot something where you absolutely, 100%, MUST understand what a line of code does&mldr; reading the assembly for the code is what you should do. Not reading the C++ source, Rust source, or even C source. And the reason for that is that source code in every language will lie to you. Not necessarily due to any fault in the programming language or compiler, but due to the limits of our own comprehension. Complex or unfamiliar language features, undefined behavior, or simply poorly written code can be difficult to understand to see what&rsquo;s <em>really</em> going on. But the assembly code will always tell you the truth.</p><p>And besides that, there are the typical cases where you read assembly language: when you don&rsquo;t have the source code. Reverse engineering something to understand how it works shouldn&rsquo;t be seen as an unapproachable skill. It&rsquo;s something every programmer should have some level of understanding of, especially if you run code on a closed source operating system or use libraries without source code.</p><p>But most importantly, understanding assembly language is essential to understanding how things really work, and can give you better insights into how things work, whether you&rsquo;re building systems up or tearing systems down. Reading assembly language is not a replacement for proper reverse engineering tools like Ghidra or IDA, but it is a necessary complimentary skill.</p><h1 id=why-reading-is-easier-than-writing>Why reading is easier than writing</h1><p>One of the hardest parts of assembly language are the fact that there are so many different instructions. The 8086 instruction set started with 81 different instructions. On a modern Intel CPU, that number is closer to 1000. You could imagine trying to find the right instruction for a specific situation would be difficult. In reality, the number of instructions you need to learn to read is quite small. In one binary I looked at, 83% of the instructions used were the 10 most frequent instructions, and many of the top 30 instructions are just slight variations (like <code>AND</code> and <code>OR</code>).</p><p>Here&rsquo;s a chart I made showing the relative frequency of the 30 most common instruction types I saw in one binary. I suspect you would see a similar graph on other architectures, but on x86 you&rsquo;ll see a particularly long tail due to the large number of instruction types. You can understand a very large chunk of assembly code if you just know the most common instructions.</p><p><img src=/mnemonic_freq.png alt="Mnemoic Frequency"></p><h1 id=how-to-read-assembly>How to read assembly</h1><p>Hopefully I&rsquo;ve convinced you that learning to read assembly language is important and not as hard as you think. So let me give you a little crash course in x86 assembly.</p><h2 id=two-flavors-att-and-intel-syntax>Two flavors: AT&amp;T and Intel syntax</h2><p>For historical reasons, there are two &ldquo;flavors&rdquo; of disassembly syntax for x86. One is called &ldquo;Intel&rdquo; and the other is called &ldquo;AT&amp;T&rdquo;. If you live in the Windows world, you may never see AT&amp;T syntax, but some open source tools will default to AT&amp;T syntax so it&rsquo;s good to recognize when you&rsquo;re dealing with it.</p><p>The biggest difference you&rsquo;ll see between the two flavors is that the order of operands is <strong>reversed</strong>! Here&rsquo;s an example of AT&amp;T syntax:</p><pre tabindex=0><code>addl $4, %eax
</code></pre><p>And here&rsquo;s an example of Intel syntax:</p><pre tabindex=0><code>add eax, 4
</code></pre><p>Besides the order being swapped, constants also get prefixed with <code>$</code>, and registers are prefixed with <code>%</code>. Some mnemonics also have a letter appended to indicate the size of the operands, such as <code>l</code> for 32-bit operands.</p><p>Depending on the tools you are using, you may not have a choice of which syntax to use. WinDbg only supports Intel syntax, for instance. Many open source tools will default to AT&amp;T syntax, but will have an option to enable Intel syntax. For <a href=https://man7.org/linux/man-pages/man1/objdump.1.html>objdump</a>, you can use <code>-M intel</code>. For instance:</p><pre tabindex=0><code>objdump -d -M intel ./a.out
</code></pre><p>While I&rsquo;m sure someone has an argument in favor of the AT&amp;T syntax, I&rsquo;d suggest avoiding it for one simple reason: The Intel manual (SDM) uses Intel syntax, and is a crucial resource to understand how an instruction works. So to avoid confusion, stick with Intel syntax.</p><h2 id=the-parts-of-an-instruction-mnemonic-operands-and-prefixes>The parts of an instruction: mnemonic, operands, and prefixes</h2><p>A single assembly language unit is an &ldquo;instruction&rdquo;, and it has three parts.</p><p>The &ldquo;mnemonic&rdquo; is the name of the instruction, like &ldquo;ADD&rdquo; or &ldquo;MOV&rdquo;, which tells you what the instruction does. Most mnemonics are an abbreviated version of a word, like MOV (move), SUB (subtract), or INC (increment). Other operations have an abbreviated phrase as the mneumoic, such as LEA (Load Effective Address), or SAL (Shift Arithmetic Left). There are complex instructions that operate on &ldquo;vectors&rdquo; (also known as SIMD or Single Instruction Multiple Data) which tend to have long and complicated names, but luckily you won&rsquo;t have to read things like PMADDUBSW very frequently (Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words).</p><p>Each instruction can take 0 to 3 operands, although 2 operands is the most common. Operands could be registers, constants, or memory locations, but not every type and combination of operand type is available for every instruction. For instance, there is no version of <code>MOV</code> that takes two memory locations, but <code>MOV reg, mem</code> and <code>MOV mem, reg</code> are both available for moving data around.<sup>2</sup></p><p>For instructions that take at least one operand, the first operand is often a destination for data to be written and is usually a <em>source</em> as well. The <code>INC EAX</code> instruction will read the value of EAX, add one, and write the value back to EAX. Any operands after the first are generally only read and not written. One notable exception to that rule is the <code>XCHG</code> instruction which can swap two registers or a register and a memory location.</p><p>Instructions can also have &ldquo;prefixes&rdquo; which modify the behavior of the instruction. The two types you are most likely to encounter are <code>LOCK</code> for making certain read/modify/write operations atomic, and <code>REP</code>/<code>REPZ</code>/<code>REPNZ</code> which are used for &ldquo;string&rdquo; operations for copying/comparing a sequence of bytes.</p><h2 id=memory-operands>Memory operands</h2><p>Intel has a flexible (and complex) set of memory addressing modes. Luckily, when reading the code you don&rsquo;t need to know most of this because with Intel syntax the address expression will always be described as a simple expression such as:</p><pre tabindex=0><code>mov     rbp,[rsp-170h]
</code></pre><p>The most complex expressions can contain two registers, a constant, and a &ldquo;scale factor&rdquo; for one of the registers. For instance:</p><pre tabindex=0><code>mov     rax,dword ptr [rbp+rcx*4+1234h]
</code></pre><p>One special instruction that takes a memory address is the <code>LEA</code> instruction, which stands for Load Effective Address. Unlike every other instruction that takes a memory operand, this one does not read or write to the address, but only calculates the <em>effective address</em> where the memory load or store would be. There&rsquo;s really no reason why the address actually has to be a memory location at all, so you sometimes see LEA being used to combine a few arithmetic operations together, since it&rsquo;s sometimes smaller and faster to do a single LEA instruction than several ADD instructions.</p><h2 id=registers>Registers</h2><p>The x64 register set has an instruction pointer (RIP) and 16 general purpose registers (RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI, R8-R15)<sup>3</sup>. By &ldquo;General Purpose&rdquo; we mean that they can be generally used for storing whatever you want in them. For instance, a <code>MOV</code> instruction can be used to move values into/out of any of the general purpose registers, but cannot directly access the instruction pointer, RIP. Although they can be used for general purpose, some of the registers have special purposes and are used implicitly by certain instructions. For example, the RSP register is always used with any operation that touches the stack, like the <code>CALL</code> and <code>PUSH</code> instructions. The RSI and RDI registers are used implicitly for any of the &ldquo;string operations&rdquo; like <code>MOVS</code>. Some registers are simply more efficient to use in certain cases, but when reading assembly code you generally don&rsquo;t need to worry about this.</p><p>While all of these registers are 64 bits, x86 can use smaller parts of most registers, and we use a different name when talking about the smaller parts of the registers. EAX is the low 32 bits of RAX. AX is the low 16 bits of RAX. AL is the low 8 bits of RAX. And we also have AH that can be used to describe the high 8 bits of AX. In general, you can use these to manipulate the bits of a larger register, such as using <code>MOV AX, 0</code> to clear out the low 16 bits of RAX. The one strange exception is that writing to the low 32-bits of a 64-bit register will clear the high 32-bits to 0.</p><pre tabindex=0><code>0:000&gt; rrax=1234567812345678
0:000&gt; u . L2
00007ffb`a8980959 b834120000      mov     eax,1234h
00007ffb`a898095f cc              int     3
0:000&gt; rrax
rax=1234567812345678
0:000&gt; p
00007ffb`a898095e cc              int     3
0:000&gt; rrax
rax=0000000000001234
</code></pre><p>Note that there are a bunch of other registers, including segment registers, debug registers, and control registers. If you&rsquo;re just starting out with reading disassembly, you won&rsquo;t need to worry about these yet. Segment registers can affect how memory loads and stores are handled. Debug registers are used to cause an exception for certain memory addresses (like a break on a memory read at a certain address). Control registers are used from kernel mode to control system-level configuration.</p><h2 id=common-instructions>Common instructions</h2><p>The most common instruction by an order of magnitude is the MOV instruction. This can be used to read memory, write memory, and to copy data between registers. Because Intel syntax puts the destination as the left-hand operand, you can think of a <code>MOV A, B</code> instruction as if it is just an assignment statement <code>A = B</code>.</p><p>The <code>CALL</code> instruction is for calling a function. This can be a direct address, or it can be an indirect address where the location of the target function is stored in a register or memory, which is useful for cases such as <a href=/posts/vtables/>function tables</a>. The actual behavior of the <code>CALL</code> instruction is to take the current instruction pointer, push it to the stack, and then replace the current instruction pointer with the value of the first operand.<sup>4</sup>. The <code>RET</code> (return) instruction does the exact opposite, and pops a value off the stack into the current instruction pointer. The <code>JMP</code> instruction is the same as <code>CALL</code> except that it does not push a return address on the stack. It&rsquo;s usually used for control flow within a function.</p><p>There are also a set of logical and arithmetic operations that follow a standard pattern. This includes <code>ADD dest, src</code>, <code>SUB dest, src</code>, <code>AND dest, src</code> and <code>XOR dest, src</code>. There are a bunch of these and they all work almost identically. <code>ADD RAX, RBX</code> in pseudocode would be <code>RAX = RAX + RBX</code>. In addition to setting the destination to the result of the operation, they also set a number of &ldquo;flags&rdquo; based on the operation. For instance, the &ldquo;zero flag&rdquo; is set if the result was zero. The flags are important because they control all of the conditional operations. For example, the <code>JZ</code> (Jump if Zero) is a jump that&rsquo;s conditional on the zero flag. If the zero flag is set, the CPU will start executing instructions at the address specified as an operand. If not, it will continue executing the instructions following the <code>JZ</code>. The same instruction has another name, which is <code>JE</code> (Jump if Equal). This tells you a little about why this flag is useful. If you want to check if two values are equal, you can subtract them and see if the result is zero. And in fact, that&rsquo;s exactly what the <code>CMP first, second</code> instruction is. It&rsquo;s a <code>SUB</code> instruction but without storing the data back to the first operand. The point is that it will set all of the flags as if it did a subtraction, but not store the result. Using the other flags, we can do other conditional jumps, such as <code>JNE</code> (Jump if Not Equal), <code>JB</code> (Jump if Below), <code>JLE</code> (Jump if Less or Equal). Note that there are some very similarly-named instructions like <code>JB</code> (Jump if Below) and <code>JL</code> (Jump if Less), and the difference is that <code>JB</code> is used for unsigned comparisons, and <code>JL</code> is used for signed comparisons. There are lots of different conditional jumps, but the most frequently seen are <code>JE</code> (also known as <code>JZ</code>) and <code>JNZ</code> (also known as <code>JNE</code>). You will see some combination of <code>JB</code>, <code>JS</code>, <code>JL</code> and others depending on whether the program uses more signed or unsigned numbers.</p><p>Similar to the <code>CMP</code> instruction is the <code>TEST</code> instruction, which also sets flags without writing to a destination register, but this one does an AND operation instead of a subtraction. A common use for this instruction, as the name implies, is testing if a bit is set.</p><p>There are a few instructions that take a single operand. <code>DEC</code> and <code>INC</code> will decrement or increment a register (or memory location), while <code>NEG</code> will negate a number (<a href=https://en.wikipedia.org/wiki/Two%27s_complement>two&rsquo;s complement</a>), and <code>NOT</code> will invert every bit of a register or memory location.</p><p>The <code>NOP</code> instruction does&mldr; nothing. It&rsquo;s short for No OPeration. While compilers have a few uses for this instruction, one that comes in handy is when you want to disable a small chunk of code (which we sometimes call &ldquo;NOP-ing out&rdquo; the instructions).</p><p>The last common instruction I&rsquo;ll mention is the <code>INT</code> instruction. It always takes a constant operand of a single byte value. It&rsquo;s short for &ldquo;INTerrupt&rdquo; and is used to trigger a &ldquo;software interrupt&rdquo;, which will switch the CPU into kernel mode and start running the code that corresponds to the interrupt number (the interrupt handler). Two important uses are breakpoints (which are always <code>INT 3</code>) and system/kernel calls, although the latter use has been mostly replaced with the <code>SYSCALL</code>/<code>SYSENTER</code> instructions because they are better suited for that purpose.</p><h1 id=see-its-not-so-hard>See, it&rsquo;s not so hard!</h1><p>If you&rsquo;ve made it this far, you should have the basic information you need to start understanding assembly code. The best way to improve past this point is to actually start reading the code that a compiler generates. The best way to do that for sample programs is to use <a href=https://godbolt.org/>Compiler Explorer</a>, which will neatly color code the correlation between source code and assembly. I also think it&rsquo;s very useful to step through assembly code and see how the registers change. For that, WinDbg is my preferred tool, but any debugger that can step at the assembly level (and not source line!) will give you a similar experience. Lastly, when you want to really understand every last detail of how an instruction works, make sure you download the latest copy of the <a href=https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html>Intel Software Developer Manuals</a>, which we usually just call &ldquo;The SDM&rdquo;. It&rsquo;s incredibly dense, but has every detail of every instruction, as well as everything else you can imagine about low level x86 and x64 programming.</p><p>Was this useful? Have any questions that weren&rsquo;t answered here? Did I make any mistakes? Let me know on <a href=https://twitter.com/timmisiak>Twitter</a> or <a href=https://dbg.social/@tim>Mastodon</a>!</p><h2 id=footnotes>Footnotes</h2><ol><li>I&rsquo;m not going to split hairs about assembly language vs. machine code. If you care about the distinction, this blog post is probably not very relevant to you. Same goes if you want to talk about microcode instead of machine code.</li><li>In fact, there are no x86 instructions that have two explicit memory operands! There <em>are</em> instructions that can read from one memory address and write to another, but one of those addresses will be implicit via some other register. For instance, the <code>PUSH [addr]</code> instruction can read a value from one address, and then write it at the current stack pointer.</li><li>Those of you with sharp eyes will notice I listed RAX, RCX, RDX, RBX and not RAX, RBX, RCX, RDX. That&rsquo;s because RAX, RCX, RDX, RBX is the correct order for the registers and almost everyone gets this wrong in diagrams online. It&rsquo;s really not important 99% of the time, but if you look any place where the registers are indexed or stored into memory, it&rsquo;s always this order.</li><li>To be more precise, the operand is evaluated and stored as a temporary value, and <em>then</em> the instruction pointer is pushed to the stack. This is important if the operand references RSP! The first time I wrote CPU emulation for this when working on <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview>Time Travel Debugging</a>, I got this wrong. It seemed to work just fine but randomly crashed when some programs jumped to the wrong address!</li></ol></div><div class=post-footer></div></article></main></body></html>