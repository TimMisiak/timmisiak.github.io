<!doctype html><html lang=en-us><head><title>Writing a Debugger From Scratch - DbgRs Part 5 - Breakpoints // TimDbg</title><link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.119.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing a Debugger From Scratch - DbgRs Part 5 - Breakpoints"><meta name=twitter:description content="(New to this series? Consider starting from part 1)
At the end of the last post, we started to get some interesting functionality with the ability to resolve addresses to names in a module. This was the last functionality missing before we could implement breakpoints! This part adds the ability for DbgRs to set hardware breakpoints.
The code for this post is in the part5 branch on github. You can also view the changes from part4."><meta property="og:title" content="Writing a Debugger From Scratch - DbgRs Part 5 - Breakpoints"><meta property="og:description" content="(New to this series? Consider starting from part 1)
At the end of the last post, we started to get some interesting functionality with the ability to resolve addresses to names in a module. This was the last functionality missing before we could implement breakpoints! This part adds the ability for DbgRs to set hardware breakpoints.
The code for this post is in the part5 branch on github. You can also view the changes from part4."><meta property="og:type" content="article"><meta property="og:url" content="/posts/writing-a-debugger-from-scratch-part-5/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-26T22:28:40-07:00"><meta property="article:modified_time" content="2023-09-26T22:28:40-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Writing a Debugger From Scratch - DbgRs Part 5 - Breakpoints</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Sep 26, 2023</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>12 min read</div></div></header><div class=post-content><p>(New to this series? Consider starting from <a href=/posts/writing-a-debugger-from-scratch-part-1>part 1</a>)</p><p>At the end of the <a href=/posts/writing-a-debugger-from-scratch-part-4>last post</a>, we started to get some interesting functionality with the ability to resolve addresses to names in a module. This was the last functionality missing before we could implement breakpoints! This part adds the ability for DbgRs to set hardware breakpoints.</p><p>The code for this post is in the <a href=https://github.com/TimMisiak/dbgrs/tree/part5>part5 branch on github</a>. You can also view the <a href=https://github.com/TimMisiak/dbgrs/compare/part4...part5>changes from part4</a>. If you see any mistakes or ways to improve the code, feel free to <a href=https://github.com/TimMisiak/dbgrs/issues>create issues</a> on the GitHub repo or submit a PR.</p><h1 id=first-some-cleanup>First, some cleanup</h1><p>I&rsquo;ve been trying to keep DbgRs as simple as possible, avoiding extra architectural layers to keep the concepts as clear and concise as possible, but now that it has grown a bit, we need a little bit of cleanup to keep things easy to understand. I&rsquo;ll just cover these changes briefly and then we&rsquo;ll get to breakpoints.</p><p>The biggest change is that I moved all of the code dealing with <a href=https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-waitfordebugeventex>WaitForDebugEventEx</a> into a new file, <a href=https://github.com/TimMisiak/dbgrs/blob/part5/src/event.rs>event.rs</a>. A single public function allows waiting for the next debug event, and returns a new <code>DebugEvent</code> enum instead of the raw win32 <code>DEBUG_EVENT</code> type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>DebugEvent</span> {
</span></span><span style=display:flex><span>    Exception{first_chance: <span style=color:#66d9ef>bool</span>, exception_code: <span style=color:#66d9ef>i32</span>},
</span></span><span style=display:flex><span>    CreateProcess{exe_name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>, exe_base: <span style=color:#66d9ef>u64</span>},
</span></span><span style=display:flex><span>    CreateThread{thread_id: <span style=color:#66d9ef>u32</span>},
</span></span><span style=display:flex><span>    ExitThread{thread_id: <span style=color:#66d9ef>u32</span>},
</span></span><span style=display:flex><span>    LoadModule{module_name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>, module_base: <span style=color:#66d9ef>u64</span>},
</span></span><span style=display:flex><span>    OutputDebugString(String),
</span></span><span style=display:flex><span>    ExitProcess,
</span></span><span style=display:flex><span>    Other(String)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventContext</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> process_id: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> thread_id: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wait_for_next_debug_event</span>(mem_source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource) -&gt; (EventContext, DebugEvent) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>As a result, the <code>main_debugger_loop</code> function is a bit smaller and can focus on the core debugger loop logic.</p><p>The other change is that I&rsquo;ve added a file called <a href=https://github.com/TimMisiak/dbgrs/blob/part5/src/util.rs>util.rs</a> which has some common helpers for win32 structures, including a thin <code>AutoClosedHandle</code> wrapper for <code>HANDLE</code> and the <code>AlignedContext</code> struct that wraps the win32 <code>CONTEXT</code>. Additionally, this includes some constants that are missing from the windows-rs crate.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[repr(align(16))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AlignedContext</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> context: <span style=color:#a6e22e>CONTEXT</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AutoClosedHandle</span>(<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>HANDLE</span>);
</span></span></code></pre></div><h1 id=evaluating-symbols>Evaluating symbols</h1><p>When setting a breakpoint, it&rsquo;s expected that you can use the name of a function, and not just the address. So to start, we need to add the capability for resolving a name to an address. Previously, we had the <code>resolve_address_to_name</code> function in <a href=https://github.com/TimMisiak/dbgrs/blob/part5/src/name_resolution.rs#L56>name_resolution.rs</a>, so we&rsquo;ll add the corresponding <code>resolve_name_to_address</code> function there as well.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>resolve_name_to_address</span>(sym: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Process) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span>, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> sym.chars().position(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;!&#39;</span>) {
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Search all modules
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Err(<span style=color:#e6db74>&#34;Not yet implemented&#34;</span>.to_string())
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        Some(pos) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> module_name <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>sym[<span style=color:#f92672>..</span>pos];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> func_name <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>sym[pos <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(module) <span style=color:#f92672>=</span> process.get_module_by_name_mut(module_name) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(addr) <span style=color:#f92672>=</span> resolve_function_in_module(module, func_name) {
</span></span><span style=display:flex><span>                    Ok(addr)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Err(format!(<span style=color:#e6db74>&#34;Could not find </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> in module </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, func_name, module_name))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                Err(format!(<span style=color:#e6db74>&#34;Could not find module </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, module_name))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For now, we&rsquo;ll take only the fully qualified name in <code>module.dll!functionName</code> <a aria-describedby=footnote-label href=#fully-qualified>form</a>, and allow only exact matches.</p><p>Using this function, we can add symbols to our evaluation grammar in <a href=https://github.com/TimMisiak/dbgrs/blob/part5/src/command.rs#L26>command.rs</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#75715e>#[rust_sitter::language]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>EvalExpr</span> {
</span></span><span style=display:flex><span>        Number(<span style=color:#75715e>#[rust_sitter::leaf(pattern = r</span><span style=color:#e6db74>&#34;(\d+|0x[0-9a-fA-F]+)&#34;</span><span style=color:#75715e>, transform = parse_int)]</span> <span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>        Symbol(<span style=color:#75715e>#[rust_sitter::leaf(pattern = r</span><span style=color:#e6db74>&#34;(([a-zA-Z0-9_@#.]+!)?[a-zA-Z0-9_@#.]+)&#34;</span><span style=color:#75715e>, transform = parse_sym)]</span> String),
</span></span></code></pre></div><p>In order to evaluate symbols, the <code>evaluate_expression</code> function now needs a context that it can use to evaluate symbols against. For this, we&rsquo;ll just pass in a structure with a reference to the <code>Process</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EvalContext</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>mut</span> Process,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>evaluate_expression</span>(expr: <span style=color:#a6e22e>EvalExpr</span>, context: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> EvalContext) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span>, String<span style=color:#f92672>&gt;</span> {
</span></span></code></pre></div><p>Note that it also returns a <code>Result</code> now because the name resolution can fail. Most of the function is unchanged besides passing the context through, and it now handles <code>EvalExpr::Symbol</code> by passing it to <code>name_resolution::resolve_to_address</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>match</span> expr {
</span></span><span style=display:flex><span>        EvalExpr::Number(x) <span style=color:#f92672>=&gt;</span> Ok(x),
</span></span><span style=display:flex><span>        EvalExpr::Add(x, _, y) <span style=color:#f92672>=&gt;</span> Ok(evaluate_expression(<span style=color:#f92672>*</span>x, context)<span style=color:#f92672>?</span> <span style=color:#f92672>+</span> evaluate_expression(<span style=color:#f92672>*</span>y, context)<span style=color:#f92672>?</span>),
</span></span><span style=display:flex><span>        EvalExpr::Symbol(sym) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            resolve_name_to_address(<span style=color:#f92672>&amp;</span>sym, context.process)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can verify this is working by simply evaluating a symbol to an address and making sure it resolves back to the same symbol.</p><pre tabindex=0><code>&gt; ? ntdll.dll!NtMapViewOfSection+0x14
 = 0x7FFE7360F154
[11254] ntdll.dll!NtMapViewOfSection+0x14
&gt; ln 0x7FFE7360F154
ntdll.dll!NtMapViewOfSection+0x14
[11254] ntdll.dll!NtMapViewOfSection+0x14
</code></pre><p>Success!</p><h1 id=keeping-track-of-breakpoints>Keeping track of breakpoints</h1><p>With the new functionality in the expression evaluator to evaluate symbols, we can add the commands for setting, clearing, and listing breakpoints. First, we add the breakpoint commands to the command grammar in <a href=https://github.com/TimMisiak/dbgrs/blob/part5/src/command.rs#L15>command.rs</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        SetBreakpoint(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;bp&#34;</span><span style=color:#75715e>)]</span> (), Box<span style=color:#f92672>&lt;</span>EvalExpr<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>        ListBreakpoints(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;bl&#34;</span><span style=color:#75715e>)]</span> ()),
</span></span><span style=display:flex><span>        ClearBreakpoint(<span style=color:#75715e>#[rust_sitter::leaf(text = </span><span style=color:#e6db74>&#34;bc&#34;</span><span style=color:#75715e>)]</span> (), Box<span style=color:#f92672>&lt;</span>EvalExpr<span style=color:#f92672>&gt;</span>),
</span></span></code></pre></div><p>The implementation of these commands need something to talk to, so we&rsquo;ll create a new structure called BreakpointManager that keeps track of the breakpoints that should be set in the process, and create this at the start of the <a href=https://github.com/TimMisiak/dbgrs/blob/part5/src/main.rs#L81>main_debugger_loop</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main_debugger_loop</span>(process: <span style=color:#a6e22e>HANDLE</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> breakpoints <span style=color:#f92672>=</span> BreakpointManager::new();
</span></span></code></pre></div><p>We&rsquo;ll get to the implementation of <code>BreakpointManager</code> in a minute, but first we can just see the simple implementation of <code>bp</code>, <code>bl</code>, and <code>bc</code> calling into the breakpoint manager.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cmd <span style=color:#f92672>=</span> command::read_command();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>match</span> cmd {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        CommandExpr::SetBreakpoint(_, expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(addr) <span style=color:#f92672>=</span> eval_expr(expr) {
</span></span><span style=display:flex><span>                breakpoints.add_breakpoint(addr);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        CommandExpr::ListBreakpoints(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            breakpoints.list_breakpoints(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> process);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        CommandExpr::ClearBreakpoint(_, expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(id) <span style=color:#f92672>=</span> eval_expr(expr) {
</span></span><span style=display:flex><span>                breakpoints.clear_breakpoint(id <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>The <code>BreakpointManager</code> contains the list of the breakpoints that have been requested by the user. It has functions for adding a breakpoint at a specified address, removing a breakpoint given its ID, and listing the breakpoints for the user.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Breakpoint</span> {
</span></span><span style=display:flex><span>    addr: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>    id: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BreakpointManager</span> {
</span></span><span style=display:flex><span>    breakpoints: Vec::<span style=color:#f92672>&lt;</span>Breakpoint<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> BreakpointManager {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_breakpoint</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, addr: <span style=color:#66d9ef>u64</span>) {
</span></span><span style=display:flex><span>        self.breakpoints.push(Breakpoint{addr, id: <span style=color:#a6e22e>self</span>.get_free_id()});
</span></span><span style=display:flex><span>        self.breakpoints.sort_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a.id.cmp(<span style=color:#f92672>&amp;</span>b.id));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>list_breakpoints</span>(<span style=color:#f92672>&amp;</span>self, process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Process) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> bp <span style=color:#66d9ef>in</span> self.breakpoints.iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(sym) <span style=color:#f92672>=</span> name_resolution::resolve_address_to_name(bp.addr, process) {
</span></span><span style=display:flex><span>                println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:3}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{:#018x}</span><span style=color:#e6db74> (</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#34;</span>, bp.id, bp.addr, sym)
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:3}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{:#018x}</span><span style=color:#e6db74>&#34;</span>, bp.id, bp.addr)
</span></span><span style=display:flex><span>            }            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>clear_breakpoint</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, id: <span style=color:#66d9ef>u32</span>) {
</span></span><span style=display:flex><span>        self.breakpoints.retain(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> x.id <span style=color:#f92672>!=</span> id)
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>We can test these commands to make sure breakpoints are tracked correctly, although we still need to apply the breakpoints to the target process before they&rsquo;ll do anything.</p><pre tabindex=0><code>Command line was: &#39;&#34;C:\git\HelloWorld\hello.exe&#34; &#39;
LoadDll: 7FF7E7420000   hello.exe
[5A70] 0x00007ffdaed4aa40
&gt; g
LoadDll: 7FFDAECF0000   ntdll.dll
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bp ntdll.dll!RtlUserThreadStart
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bl
  0 0x00007ffdaed4aa40 (ntdll.dll!RtlUserThreadStart)
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bc 0
[5A70] ntdll.dll!RtlUserThreadStart
&gt; bl
[5A70] ntdll.dll!RtlUserThreadStart
&gt; 
</code></pre><h1 id=applying-breakpoints>Applying breakpoints</h1><p>Finally, we can get to the fun part where we apply the breakpoints to a process. There are two types of breakpoints, software breakpoints and hardware breakpoints. Of the two, hardware breakpoints are less complicated, so we&rsquo;ll start with those. On x86 processors the hardware breakpoints are controlled via the <a href=https://wiki.osdev.org/CPU_Registers_x86-64#Debug_Registers>&ldquo;Debug Registers&rdquo;</a>. There are four hardware breakpoints available on current CPUs. Debug registers DR0 through DR3 are used to specify the address of the breakpoint. Register DR6 is a status register to determine when a breakpoint is hit. And DR7 is a control register to specify the attributes of each hardware breakpoint. Note that there are a number of fields packed together in DR7, so we&rsquo;ll use a little helper to set these fields.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Helper function to set a value at a specific bit offset.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_bits</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>PrimInt</span><span style=color:#f92672>&gt;</span>(val: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> T, set_val: <span style=color:#a6e22e>T</span>, start_bit: <span style=color:#66d9ef>usize</span>, bit_count: <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// First, mask out the relevant bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> max_bits <span style=color:#f92672>=</span> std::mem::size_of::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mask: <span style=color:#a6e22e>T</span> <span style=color:#f92672>=</span> T::max_value() <span style=color:#f92672>&lt;&lt;</span> (max_bits <span style=color:#f92672>-</span> bit_count);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mask: <span style=color:#a6e22e>T</span> <span style=color:#f92672>=</span> mask <span style=color:#f92672>&gt;&gt;</span> (max_bits <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> start_bit);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> inv_mask <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>mask;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>val <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>val <span style=color:#f92672>&amp;</span> inv_mask;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>val <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>val <span style=color:#f92672>|</span> (set_val <span style=color:#f92672>&lt;&lt;</span> (start_bit <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> bit_count));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To manipulate these registers, we&rsquo;ll use the <code>GetThreadContext</code>/<code>SetThreadContext</code> functions to set the registers to the state needed for the requested breakpoints. Note that the debug registers are maintained for each thread separately, so we could theoretically set different breakpoints for each thread, or filter a breakpoint to a specific thread. That functionality won&rsquo;t be implemented in DbgRs for now, and we&rsquo;ll just apply the same breakpoints to all threads. To start, we&rsquo;ll loop over all of the threads in the process and retrieve each thread&rsquo;s context:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>apply_breakpoints</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Process, resume_thread_id: <span style=color:#66d9ef>u32</span>, _memory_source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> thread_id <span style=color:#66d9ef>in</span> process.iterate_threads() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ctx: <span style=color:#a6e22e>AlignedContext</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { std::mem::zeroed() };
</span></span><span style=display:flex><span>            ctx.context.ContextFlags <span style=color:#f92672>=</span> <span style=color:#66d9ef>CONTEXT_ALL</span>;            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> thread <span style=color:#f92672>=</span> AutoClosedHandle(<span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>                OpenThread(
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>THREAD_GET_CONTEXT</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>THREAD_SET_CONTEXT</span>,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>FALSE</span>,
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>thread_id,
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> ret <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { GetThreadContext(thread.handle(), <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> ctx.context) };
</span></span></code></pre></div><p>We&rsquo;ll then loop over the requested breakpoints. We need to set four pieces of information for each one. The three fields to set are the LEN (length), RW (access type), and LE (local enable) configuration for each breakpoint. We&rsquo;ll set the <a aria-describedby=footnote-label href=#execute-len>LEN to 0</a>, which indicates 1 byte. We&rsquo;ll set RW to 0, which means &ldquo;break on instruction execution&rdquo; (we would use a value of 1 indicate break on read or a value of 3 to indicate break on read or write). Finally, we&rsquo;ll set the &ldquo;local enable&rdquo; bit to 1 indicating that the breakpoint should be enabled.</p><p><img src=/dr7.png alt="DR7 layout"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> idx <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>4</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.breakpoints.len() <span style=color:#f92672>&gt;</span> idx {
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The DR7_* variables are a set of constants with the correct offsets and sizes for each
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// field of DR7.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            set_bits(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> ctx.context.Dr7, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>DR7_LEN_BIT</span>[idx], <span style=color:#66d9ef>DR7_LEN_SIZE</span>);
</span></span><span style=display:flex><span>            set_bits(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> ctx.context.Dr7, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>DR7_RW_BIT</span>[idx], <span style=color:#66d9ef>DR7_RW_SIZE</span>);
</span></span><span style=display:flex><span>            set_bits(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> ctx.context.Dr7, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>DR7_LE_BIT</span>[idx], <span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><p>The appropriate DR0-DR3 value will be set to the address of the resolved breakpoint.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> idx {
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> ctx.context.Dr0 <span style=color:#f92672>=</span> self.breakpoints[idx].addr,
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> ctx.context.Dr1 <span style=color:#f92672>=</span> self.breakpoints[idx].addr,
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> ctx.context.Dr2 <span style=color:#f92672>=</span> self.breakpoints[idx].addr,
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>3</span> <span style=color:#f92672>=&gt;</span> ctx.context.Dr3 <span style=color:#f92672>=</span> self.breakpoints[idx].addr,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> (),
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>Finally, we&rsquo;ll make sure to disable any breakpoints that we are not using. Note that the code assumes that the debugger &ldquo;owns&rdquo; the debug registers and that the target process is not using them in any way. This is typically true, but there are cases where the target process will be using the debug registers for its own purpose, or are manipulated as an anti-debugging technique. To keep things simple, we won&rsquo;t worry about that and just clear the local enable (LE) bit.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Disable any breakpoints that we aren&#39;t using.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            set_bits(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> ctx.context.Dr7, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>DR7_LE_BIT</span>[idx], <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }    
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This new function, <code>apply_breakpoints</code>, will be called from the <code>main_debugger_loop</code> right before we call <code>ContinueDebugEvent</code>. That will ensure that we set up all thread contexts with the correct breakpoint state. Note that because Windows sends a debug event for thread creation, we&rsquo;ll have an opportunity to set the breakpoint state for all new threads that are created.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    breakpoints.apply_breakpoints(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> process, event_context.thread_id, mem_source.as_ref());
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        ContinueDebugEvent(
</span></span><span style=display:flex><span>            event_context.process_id,
</span></span><span style=display:flex><span>            event_context.thread_id,
</span></span><span style=display:flex><span>            continue_status,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h1 id=handling-breakpoint-exceptions>Handling breakpoint exceptions</h1><p>When the CPU tries to execute an instruction that is marked with a debug register, it generates a debug exception (#DB) as a <a href=https://wiki.osdev.org/Exceptions>fault</a> (It&rsquo;s important to note this is a fault, and not a trap. More on that later). Windows delivers this to a debugger as an exception event with exception code 0x80000004. The thread context will also have a flag set in DR6 indicating which breakpoint was hit. We&rsquo;ll add some code in the exception event handler letting the breakpoint manager check if a breakpoint was hit.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#66d9ef>match</span> debug_event {
</span></span><span style=display:flex><span>            DebugEvent::Exception { first_chance, exception_code } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(bp_index) <span style=color:#f92672>=</span> breakpoints.was_breakpoint_hit(<span style=color:#f92672>&amp;</span>ctx.context) {
</span></span><span style=display:flex><span>                    println!(<span style=color:#e6db74>&#34;Breakpoint </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> hit&#34;</span>, bp_index);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// It&#39;s important to use DBG_CONTINUE with ContinueDebugEvent or else the breakpoint will be treated
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// as an exception to be handled by the target process.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    continue_status <span style=color:#f92672>=</span> <span style=color:#66d9ef>DBG_CONTINUE</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>//...
</span></span></span></code></pre></div><p>The breakpoint manager will just check DR6 to see if any of the bits were set that correspond to a hardware breakpoint triggering.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>was_breakpoint_hit</span>(<span style=color:#f92672>&amp;</span>self, thread_context: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>CONTEXT</span>) -&gt; Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> idx <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.breakpoints.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> get_bit(thread_context.Dr6, <span style=color:#66d9ef>DR6_B_BIT</span>[idx]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(idx <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Remember how I mentioned that hardware breakpoints trigger debug exceptions as a <a aria-describedby=footnote-label href=#debug-fault>fault</a>? That&rsquo;s important because a &ldquo;fault&rdquo; exception triggers <em>before</em> the instruction has a chance to execute. That lets us examine state before the instruction executes, which is what we want for a debugger. But since it is a fault, resuming the execution of the program just causes the program to break in again! On some architectures, this might be complicated to get past, but on x86 we simply have to set the &ldquo;resume flag&rdquo;, which is one of the bits in the EFlags registers that often gets overlooked. The resume flag causes the processor to ignore instruction breakpoints for a single instruction execution. It is set back to 0 right after the debug registers would have been checked, which makes it a convenient tool for resuming execution. We&rsquo;ll set this flag on whatever thread caused the debugger to break in, regardless of whether the breakpoint has hit or not. (Some debuggers will only set RF when a breakpoint was hit). We&rsquo;ll set the resume flag inside the <code>apply_breakpoints</code> function, since it&rsquo;s already manipulating the register contexts of all threads.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>thread_id <span style=color:#f92672>==</span> resume_thread_id {
</span></span><span style=display:flex><span>        set_bits(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> ctx.context.EFlags, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>EFLAG_RF</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=testing-it-out>Testing it out</h2><p>Now that we can set a breakpoint, apply a breakpoint, and handle a breakpoint exception, we&rsquo;re ready to test out the new breakpoint functionality. To do that, we&rsquo;ll just continue execution until kernelbase is loaded, and then set a breakpoint on kernelbase!GetLastError, which is a very frequently used function that should get called almost immediately.</p><pre tabindex=0><code>Command line was: &#39;&#34;C:\git\HelloWorld\hello.exe&#34; &#39;
LoadDll: 7FF7E7420000   hello.exe
[5CF8] 0x00007ffdaed4aa40
&gt; g
LoadDll: 7FFDAECF0000   ntdll.dll
[5CF8] ntdll.dll!RtlUserThreadStart
&gt; g
LoadDll: 7FFDAD6E0000   C:\Windows\System32\KERNEL32.DLL
[5CF8] ntdll.dll!NtMapViewOfSection+0x14
&gt; g
LoadDll: 7FFDAC0A0000   C:\Windows\System32\KERNELBASE.dll
[5CF8] ntdll.dll!NtMapViewOfSection+0x14
&gt; bp kernelbase.dll!GetLastError
[5CF8] ntdll.dll!NtMapViewOfSection+0x14
&gt; g
Breakpoint 0 hit
[5CF8] C:\Windows\System32\KERNELBASE.dll!GetLastError
&gt; 
</code></pre><p>It works! It&rsquo;s almost starting to feel like a real debugger. A few very important things are left though. To start with, we can&rsquo;t see the functions that are on the call stack. Viewing the stack is probably the single most important analysis feature of a debugger. So that&rsquo;s likely where we&rsquo;re going next.</p><p>I hope you found this post interesting and informative! Have a question or suggestion? Let me know! You can find me on <a href=https://twitter.com/timmisiak>Twitter</a>, <a href=https://dbg.social/@tim>Mastodon</a>, and <a href=https://bsky.app/profile/timdbg.com>Bluesky</a>.</p><footer><h2 id=footnote-label>Footnotes</h2><ol><li id=fully-qualified>This isn't actually sufficient to uniquely identify a symbolic name. You can have multiple versions of a module with the same name loaded into the same process. This is why WinDbg will sometimes add a disambiguation in the form of "module_baseAddress".</li><li id=execute-len>For data breakpoints, the length can be used to specify a 1, 2, 4, or 8 byte range. This lets us set breakpoints appropriate to the data being monitored. For instruction execution breakpoints, however, only 1-byte ranges are allowed. Any value besides 0 in the LEN field is considered undefined.</li><li id=debug-fault>Whether a breakpoint exception is delivered as a fault or as a trap is dependent on a number of conditions (described by a decent-sized table in the Intel processor manual). But the short version is that most debug exceptions are actually traps instead of faults. Only hardware breakpoints where the RW flag is set to 0 (execute) are treated as faults. Which is a good thing, because it's way more useful to break before an instruction has a chance to execute.</li></ol></footer></div><div class=post-footer></div></article></main></body></html>