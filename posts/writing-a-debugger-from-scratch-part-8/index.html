<!doctype html><html lang=en-us><head><title>Writing a Debugger From Scratch - DbgRs Part 8 - Source and Symbols // TimDbg</title>
<link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.126.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX")}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing a Debugger From Scratch - DbgRs Part 8 - Source and Symbols"><meta name=twitter:description content="(New to this series? Consider starting from part 1)
At the end of the last post, DbgRs got the ability to disassemble the code that it was debugging. While disassembly is critical for many debugging tasks, using source code to step through the code line by line is usually more convenient when it’s available. In this post we’ll start looking at how to use symbols (PDB files on Windows) so that we can display the source for the code that’s being debugged."><meta property="og:url" content="/posts/writing-a-debugger-from-scratch-part-8/"><meta property="og:site_name" content="TimDbg"><meta property="og:title" content="Writing a Debugger From Scratch - DbgRs Part 8 - Source and Symbols"><meta property="og:description" content="(New to this series? Consider starting from part 1)
At the end of the last post, DbgRs got the ability to disassemble the code that it was debugging. While disassembly is critical for many debugging tasks, using source code to step through the code line by line is usually more convenient when it’s available. In this post we’ll start looking at how to use symbols (PDB files on Windows) so that we can display the source for the code that’s being debugged."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-29T08:50:13-07:00"><meta property="article:modified_time" content="2024-05-29T08:50:13-07:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Writing a Debugger From Scratch - DbgRs Part 8 - Source and Symbols</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
May 29, 2024</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
19 min read</div></div></header><div class=post-content><p>(New to this series? Consider starting from <a href=/posts/writing-a-debugger-from-scratch-part-1>part 1</a>)</p><p>At the end of the <a href=/posts/writing-a-debugger-from-scratch-part-7>last post</a>, DbgRs got the ability to disassemble the code that it was debugging. While disassembly is critical for many debugging tasks, using source code to step through the code line by line is usually more convenient when it&rsquo;s available. In this post we&rsquo;ll start looking at how to use symbols (PDB files on Windows) so that we can display the source for the code that&rsquo;s being debugged.</p><p>The DbgRs code for this post is in the <a href=https://github.com/TimMisiak/dbgrs/tree/part8>part8 branch on github</a>. You can also view the <a href=https://github.com/TimMisiak/dbgrs/compare/part7...part8>changes from part7</a>. If you spot any mistakes or have suggestions for improving the code, feel free to <a href=https://github.com/TimMisiak/dbgrs/issues>create issues</a> on the GitHub repo or submit a PR.</p><h1 id=whats-in-a-pdb>What&rsquo;s in a PDB?</h1><p>A symbol file is the debugger&rsquo;s link between the compiled code and the original source code. Not just the correlation between the lines of code and the assembly instructions, but also function signatures, type definitions, local variables, and more. In the Windows world, this file is called a &ldquo;PDB File&rdquo;, which <a href=https://web.archive.org/web/20160324115412/https://support.microsoft.com/en-us/kb/121366>stands for Program DataBase</a>. (Previously, debug information was stored directly in the executable, or <a aria-describedby=footnote-label href=#dbg-files>optionally in a .DBG file</a> but this is a long-dead format). These days, there are a number of different symbol formats known as &ldquo;PDB&rdquo;, including the <a href=https://github.com/dotnet/runtime/blob/main/docs/design/specs/PortablePdb-Metadata.md>.NET &ldquo;Portable PDB&rdquo;</a> format, as well as the <a href=https://devblogs.microsoft.com/cppblog/faster-c-build-cycle-in-vs-15-with-debugfastlink/>&ldquo;Fastlink&rdquo; PDB</a> format that relies on the debug information on the original .OBJ files. For the purpose of this blog post, however, we will ignore those and focus on the &ldquo;original&rdquo; flavor of PDB.</p><p>While the PDB format is not documented, Microsoft released the <a href=https://github.com/microsoft/microsoft-pdb/>Microsoft-PDB repo</a> which contains the source code to a number of key tools that were used for generating and parsing the PDB format. That&rsquo;s been sufficient for a number of other projects including LLVM to create PDB files that are compatible with WinDbg and Visual Studio. It&rsquo;s also been the basis for some open source projects that parse Windows PDB files including the <a href=https://crates.io/crates/pdb>pdb crate</a> used by DbgRs.</p><p>I&rsquo;m not going to cover the file format in depth, but I think it&rsquo;s useful to understand the rough outline of <a aria-describedby=footnote-label href=#llvm-pdb-docs>what a PDB contains</a>. At the top level you have the <a href=https://llvm.org/docs/PDB/MsfFile.html>MSF</a> (Multi-Stream File) container that allows a file to be broken up into a collection of numbered streams. It&rsquo;s a sort of mini-filesystem where individual blocks of the file can be allocated to different streams. Several fixed stream indices are used (streams 0-4), and one of these streams (stream 1, the &ldquo;PDB stream&rdquo;) includes a name/index mapping to allow streams to have a <a aria-describedby=footnote-label href=#named-streams>name in addition to an index</a>.</p><p>Some of the information, like the type description stream, is global for the entire binary and is stored in a single named or indexed stream. The rest of the information is stored on a per-module basis, where the &ldquo;modules&rdquo; are the individual compilation units (like OBJ and LIB files) that were statically linked together to create the binary. The list of modules is stored in the &ldquo;DBI stream&rdquo; (index 3) and each module has an MSF stream where the symbol information is stored. That stream of data is split into two important parts: The &ldquo;Symbol Table&rdquo; and the &ldquo;Line Data&rdquo;.</p><h2 id=the-symbol-table>The Symbol Table</h2><p>The Symbol Table is a sequence of variable-length <a aria-describedby=footnote-label href=#codeview-records>records</a>, each with a type field that indicates what sort of information is contained. For instance, the S_GPROC32 indicates the start of a global procedure. There are more than a hundred <a href=https://github.com/microsoft/microsoft-pdb/blob/805655a28bd8198004be2ac27e6e0290121a5e89/include/cvinfo.h#L2736>different types of records</a>. The ordering of the records is important, as there are &ldquo;start&rdquo; and &ldquo;end&rdquo; records of various types. For instance, there can be various records annotating information about a procedure in between an S_GPROC32 record and the terminating S_END record. These child records can describe exception handlers, local variables, parameters, and more.</p><p>We&rsquo;ll look more at the other record types later, but we can start by just looking at the S_GPROC32 and similar entries to get better name resolution in our expression evaluator. Our current name to address resolution only works for export functions, which is pretty inconvenient. We&rsquo;ll start by factoring out the code for searching the exports, and adding a new function that looks at the symbol information:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>resolve_function_in_module</span>(module: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Module, func: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We&#39;ll search exports first and private symbols next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> export_resolution <span style=color:#f92672>=</span> resolve_export_in_module(module, func);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> export_resolution.is_some() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> export_resolution;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    resolve_symbol_name_in_module(module, func).unwrap_or(None)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To resolve a name to an address, we&rsquo;ll need to get the list of modules (compilation units) described by the DBI stream. We&rsquo;ll also need the &ldquo;address map&rdquo; that allows mapping between a section index + offset in the original unoptimized binary to the final RVA as it exists in the binary we are debugging.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>resolve_symbol_name_in_module</span>(module: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Module, func: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>, anyhow::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pdb <span style=color:#f92672>=</span> module.pdb.as_mut().ok_or(anyhow!(<span style=color:#e6db74>&#34;No PDB loaded&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dbi <span style=color:#f92672>=</span> pdb.debug_information()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> modules <span style=color:#f92672>=</span> dbi.modules()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> address_map <span style=color:#f92672>=</span> module.address_map.as_mut().ok_or(anyhow!(<span style=color:#e6db74>&#34;No address map available&#34;</span>))<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>Given a function name, we don&rsquo;t know which compilation unit it came from, so we&rsquo;ll search through each module in order, and for each module we&rsquo;ll iterate over the contained symbol records.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(pdb_module) <span style=color:#f92672>=</span> modules.next()<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> mi <span style=color:#f92672>=</span> pdb.module_info(<span style=color:#f92672>&amp;</span>pdb_module)<span style=color:#f92672>?</span>.ok_or(anyhow!(<span style=color:#e6db74>&#34;Couldn&#39;t get module info&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> symbols <span style=color:#f92672>=</span> mi.symbols()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(sym) <span style=color:#f92672>=</span> symbols.next()<span style=color:#f92672>?</span> {
</span></span></code></pre></div><p>The pdb crate we&rsquo;re using has a nice way of representing symbol data so that various related records like S_GPROC32 and S_LPROC32 can all be represented as a single logical type. So we can look for anything that&rsquo;s a &ldquo;Procedure&rdquo; and check if it has a name that matches the name we are looking for. If we find it, we&rsquo;ll convert the section index + offset into an RVA, and then convert that to a virtual address by adding the module base.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(parsed) <span style=color:#f92672>=</span> sym.parse() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> SymbolData::Procedure(proc_data) <span style=color:#f92672>=</span> parsed {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> proc_data.name.to_string() <span style=color:#f92672>==</span> func {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> rva <span style=color:#f92672>=</span> proc_data.offset.to_rva(address_map).ok_or(anyhow!(<span style=color:#e6db74>&#34;Couldn&#39;t convert procedure offset to RVA&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> address <span style=color:#f92672>=</span> module.address <span style=color:#f92672>+</span> rva.<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> Ok(Some(address));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Ok(None)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We already had the resolve_function_in_module function connected to the <a aria-describedby=footnote-label href=#other-eval-changes>expression evaluator</a>, so we should be able to use this with the &ldquo;bp&rdquo; command right away. Let&rsquo;s try it.</p><pre tabindex=0><code>Command line was: &#39;&#34;C:\git\HelloWorld\hello.exe&#34; &#39;
LoadDll: 7FF7AB070000   hello.exe
[87F0] 0x00007ffecfe2aa20
&gt; bp hello!main
[87F0] 0x00007ffecfe2aa20
&gt; g
LoadDll: 7FFECFDD0000   ntdll.dll
[87F0] ntdll.dll!RtlUserThreadStart
&gt; g
LoadDll: 7FFECE9F0000   C:\Windows\System32\KERNEL32.DLL
[87F0] ntdll.dll!NtMapViewOfSection+0x14
&gt; g
LoadDll: 7FFECD280000   
[87F0] ntdll.dll!NtMapViewOfSection+0x14
&gt; g
Exception code 80000003 (first chance)
[87F0] ntdll.dll!LdrInitShimEngineDynamic+0x345
&gt; g
Breakpoint 0 hit
[87F0] hello.exe!main
&gt; 
</code></pre><p>With that out of the way, we can start looking at how to use the line data to map between code addresses and source lines.</p><h2 id=mapping-addresses-to-line-numbers>Mapping Addresses to Line Numbers</h2><p>The information about line number mapping is stored in the &ldquo;Line Data&rdquo; (aka <a href=https://github.com/microsoft/microsoft-pdb/blob/master/PDB/dbi/dbi.h#L1146>line number debug info</a>), which is in the MSF stream for the module, immediately following the symbol table. We can use this information to map a code address like the current instruction pointer to a file name and line number. Using that we can load the corresponding source file and display each line to the user as they step through the code. We&rsquo;ll start by grabbing the <code>pdb</code> object that gives us access to the contents of the symbol file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>resolve_address_to_source_line</span>(address: <span style=color:#66d9ef>u64</span>, process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Process) -&gt; Result<span style=color:#f92672>&lt;</span>(String, <span style=color:#66d9ef>u32</span>)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> module <span style=color:#f92672>=</span> process.get_containing_module_mut(address).ok_or(anyhow!(<span style=color:#e6db74>&#34;Module not found&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pdb <span style=color:#f92672>=</span> module.pdb.as_mut().ok_or(anyhow!(<span style=color:#e6db74>&#34;Symbols not available&#34;</span>))<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>The source line information, like most data in the PDB file, is stored in terms of the original section number and section offset, so we first need to convert from an address in the process to an RVA, and then from an RVA to the original section + offset address, which the PDB module calls an &ldquo;internal offset&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> address_map <span style=color:#f92672>=</span> module.address_map.as_mut().ok_or(anyhow!(<span style=color:#e6db74>&#34;Address map not found for module&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rva: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> (address <span style=color:#f92672>-</span> module.address).try_into()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rva <span style=color:#f92672>=</span> Rva(rva);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> offset <span style=color:#f92672>=</span> rva.to_internal_offset(address_map).ok_or(anyhow!(<span style=color:#e6db74>&#34;Couldn&#39;t map address&#34;</span>))<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>Next, we&rsquo;ll <a aria-describedby=footnote-label href=#faster-source-lookups>enumerate over all the compilation units/modules</a> looking for one that contains a line mapping for the offset that we just found.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dbi <span style=color:#f92672>=</span> pdb.debug_information()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> modules <span style=color:#f92672>=</span> dbi.modules()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(module) <span style=color:#f92672>=</span> modules.next()<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(Some(mi)) <span style=color:#f92672>=</span> pdb.module_info(<span style=color:#f92672>&amp;</span>module) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(lp) <span style=color:#f92672>=</span> mi.line_program() {
</span></span></code></pre></div><p>The PDB stores line mappings in chunks that correspond to functions or parts of functions. We can use the pdb to get the group of line mappings that corresponds to a particular address, but we&rsquo;ll still have to enumerate over the line mappings to find the right one. Source lines are not one-to-one mapped with code addresses. A single line of source typically compiles to multiple assembly instructions. Beyond that, optimizations can cause more ambiguity when resolving a source line to an address (more on that later). But mapping from a code address to a source line is <a aria-describedby=footnote-label href=#code-to-line-duplicates>mostly unambiguous</a>, and we can simply find the first line entry that contains the code address we&rsquo;re looking for.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> lp.lines_for_symbol(offset);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(line) <span style=color:#f92672>=</span> lines.next()<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> line.offset.offset <span style=color:#f92672>&lt;=</span> offset.offset {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> diff <span style=color:#f92672>=</span> offset.offset <span style=color:#f92672>-</span> line.offset.offset;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> diff <span style=color:#f92672>&lt;</span> line.length.unwrap_or(<span style=color:#ae81ff>0</span>) {
</span></span></code></pre></div><p>Once we find the right one, we can look up the information about the source file in a separate table, and then use information in that structure to get the actual name of the file from the &ldquo;string table&rdquo; (used by the PDB format to deduplicate common strings). And at this point, we have a source file and line number to return.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> file_info <span style=color:#f92672>=</span> lp.get_file_info(line.file_index)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> string_table <span style=color:#f92672>=</span> pdb.string_table()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> file_name <span style=color:#f92672>=</span> string_table.get(file_info.name)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> Ok((file_name.to_string().into(), line.line_start))
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Err(anyhow!(<span style=color:#e6db74>&#34;Address not found&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using this we&rsquo;ll hook up a simple &ldquo;lsa&rdquo; command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    CommandExpr::ListSource(_, expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(val) <span style=color:#f92672>=</span> eval_expr(expr) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> resolve_address_to_source_line(val, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> process) {
</span></span><span style=display:flex><span>                Ok((file_name, line_number)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    println!(<span style=color:#e6db74>&#34;LSA: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, file_name, line_number);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(file) <span style=color:#f92672>=</span> File::open(<span style=color:#f92672>&amp;</span>file_name) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> reader <span style=color:#f92672>=</span> io::BufReader::new(file);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> lines: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> reader.lines().map(<span style=color:#f92672>|</span>l<span style=color:#f92672>|</span> l.unwrap_or(<span style=color:#e6db74>&#34;&#34;</span>.to_string())) .collect();
</span></span></code></pre></div><p>And to make sure there&rsquo;s enough context, we&rsquo;ll print a small window of source lines around the target line. One important thing to remember is that line numbers are not 0-indexed, since the first line of a file is line 1!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> print_line_num <span style=color:#66d9ef>in</span> (max(<span style=color:#ae81ff>1</span>, line_number <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>))<span style=color:#f92672>..=</span>(min(lines.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>, line_number <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>)) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> print_line_num <span style=color:#f92672>==</span> line_number {
</span></span><span style=display:flex><span>                                println!(<span style=color:#e6db74>&#34;&gt;</span><span style=color:#e6db74>{:4}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, print_line_num, lines[print_line_num <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>                            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:5}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, print_line_num, lines[print_line_num <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        println!(<span style=color:#e6db74>&#34;Couldn&#39;t open file: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, file_name);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    println!(<span style=color:#e6db74>&#34;Couldn&#39;t look up source: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }                        
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now we get back source files and line numbers!</p><pre tabindex=0><code>&gt; lsa hello!main
LSA: C:\git\HelloWorld\hello.cpp:35
   33: 
   34: int main()
&gt;  35: {
   36:     printf(&#34;Hello world, %d&#34;, func1());
   37:     printf(&#34;Hello world 2!&#34;);
</code></pre><p>The source file came back as an absolute path, so we were able to find the file that was just compiled locally. But some compilation settings will result in a relative path being stored, and binaries that were compiled on a different machine likely won&rsquo;t have the right source path for the local machine even if it is an absolute path. If we try to list the source for one of the CRT functions, we get this.</p><pre tabindex=0><code>&gt; lsa hello!common_lseek_do_seek_nolock
LSA: minkernel\crts\ucrt\src\appcrt\lowio\lseek.cpp:22
Couldn&#39;t open file: minkernel\crts\ucrt\src\appcrt\lowio\lseek.cpp
</code></pre><p>To get this working, we&rsquo;ll need to implement source search functionality.</p><h3 id=source-search>Source search</h3><p>The relative path found in the symbols for the UCRT source file can&rsquo;t be opened directly, even though I do have the source file available in my SDK install folder. We can get these paths to match up by creating a source search algorithm that takes a set of search paths as potential &ldquo;roots&rdquo; to combine with the source path we are looking for. First, we&rsquo;ll add a &ldquo;.srcpath&rdquo; command that can set a Vec of search paths.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    CommandExpr::SrcPath(_, path) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        source_search_paths.clear();
</span></span><span style=display:flex><span>        source_search_paths.extend(path.split(<span style=color:#e6db74>&#39;;&#39;</span>).map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s.to_string()));
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now given that list of search paths, we need to find the correct matching path. If the path is an absolute path and exists, we&rsquo;ll just return that source file. Otherwise, we&rsquo;ll start iterating through the list of search paths. For each one, we&rsquo;ll start with the full starting path minus any drive specifier, e.g. &ldquo;minkernel\crts\ucrt\src\appcrt\lowio\lseek.cpp&rdquo; and append it to the search path. If the file isn&rsquo;t found, we&rsquo;ll start removing path elements from the front, one by one, looking for existing files on disk, until we&rsquo;re left with just the filename appended to the search path. That way, a search path can point to different levels of the filesystem and still find the right source file as long as some trailing part of the original path matches a local file. So even if the original path was on &ldquo;Z:\foo\bar\baz\file.cpp&rdquo;, we can store the files at &ldquo;C:\src\baz\file.cpp&rdquo; and have a search path of &ldquo;C:\src&rdquo; and the file will be found.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>find_source_file_match</span>(file: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, search_paths: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>PathBuf<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> file_path <span style=color:#f92672>=</span> Path::new(file);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the file path is absolute and exists, return it immediately.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> file_path.is_absolute() <span style=color:#f92672>&amp;&amp;</span> file_path.exists() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Ok(file_path.to_path_buf());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get all subsets of the input path.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> components: Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> file_path.components().map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c.as_os_str().to_str().unwrap()).collect();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> search_path <span style=color:#66d9ef>in</span> search_paths {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> search_path <span style=color:#f92672>=</span> Path::new(search_path);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>components.len() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Join the search path with the subset of the input path.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> test_path: <span style=color:#a6e22e>PathBuf</span> <span style=color:#f92672>=</span> search_path.join(components[i<span style=color:#f92672>..</span>].iter().collect::<span style=color:#f92672>&lt;</span>PathBuf<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> test_path.exists() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Ok(test_path.to_path_buf());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Err(anyhow!(<span style=color:#e6db74>&#34;File not found&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we go back to the case that failed earlier and add a search path pointing to the ucrt source in my local installation of the SDK, we&rsquo;ll see that DbgRs can now find this file.</p><pre tabindex=0><code>&gt; .srcpath C:\Program Files (x86)\Windows Kits\10\Source\10.0.22000.0\ucrt 
[8AC8] 0x00007ffecfe2aa20
&gt; lsa hello!common_lseek_do_seek_nolock
LSA: minkernel\crts\ucrt\src\appcrt\lowio\lseek.cpp:22
Found matching file: C:\Program Files (x86)\Windows Kits\10\Source\10.0.22000.0\ucrt\lowio\lseek.cpp
   20: // end up moving out of range of 32-bit values.
   21: static long __cdecl common_lseek_do_seek_nolock(HANDLE const os_handle, long const offset, int const origin, __crt_cached_ptd_host&amp; ptd) throw()
&gt;  22: {
   23:     LARGE_INTEGER const origin_pos = { 0 };
   24: 
</code></pre><p>It works! Now there is one more problem here, and that is that the content of the file could be totally wrong. Maybe it&rsquo;s the wrong commit of a repository, or the filename just happens to match and is an unrelated file. Fortunately, the PDB file includes a hash of the source file as it was compiled. There are a number of different hash algorithms that can be used, but new compilers will default to a SHA256 hash. So we can pass that hash along to the find_source_file_match function and it can use that to reject any source files without a matching hash. But for the purposes of DbgRs, I&rsquo;ll leave that functionality out. (Feel free to make a PR if you&rsquo;d like to contribute!)</p><h2 id=mapping-line-numbers-to-addresses>Mapping line numbers to addresses</h2><p>While we&rsquo;re stepping through the code, we need to map each address to the corresponding source line, but when setting a source-level breakpoint, we need to do the opposite and map a source line to an address. To do that we&rsquo;ll extend the expression evaluator to take a syntax that allows us to specify the module, source file name, and line number, and allow that to resolve back to an address that we can use for a breakpoint. This is going to be a bit of a verbose syntax to type on the command line, but if DbgRs gets integrated into a GUI like VsCode, all that information <a aria-describedby=footnote-label href=#source-file-info>will be available in the UI layer</a> to pass along to the debugging engline.</p><p>The syntax for specifying a source line in WinDbg involves using the <code>@@masm</code> syntax, which is a bit arcane:</p><pre tabindex=0><code>0:000&gt; ? @@masm(`notepad__!C:\git\npp\PowerEditor\src\winmain.cpp:721`)
Evaluate expression: 140697038077034 = 00007ff6`94f9bc6a
</code></pre><p>We&rsquo;ll simplify that a bit to get rid of the &ldquo;masm&rdquo; part but otherwise leave it mostly the same. We can add a new case for our EvalExpr enumeration, and add a regular expression that tries to parse something that looks roughly like &ldquo;module!file:line&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#75715e>#[rust_sitter::language]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>EvalExpr</span> {
</span></span><span style=display:flex><span>        Number(<span style=color:#75715e>#[rust_sitter::leaf(pattern = r</span><span style=color:#e6db74>&#34;(\d+|0x[0-9a-fA-F]+)&#34;</span><span style=color:#75715e>, transform = parse_int)]</span> <span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>        Symbol(<span style=color:#75715e>#[rust_sitter::leaf(pattern = r</span><span style=color:#e6db74>&#34;(([a-zA-Z0-9_@#.]+!)?[a-zA-Z0-9_@#.]+)&#34;</span><span style=color:#75715e>, transform = parse_sym)]</span> String),
</span></span><span style=display:flex><span>        SourceLine(<span style=color:#75715e>#[rust_sitter::leaf(pattern = r</span><span style=color:#e6db74>&#34;(`[^`!]+!(?:[a-zA-Z]+:)[^`:!]+:\d+`)&#34;</span><span style=color:#75715e>, transform = parse_source_line)]</span> (String, String, <span style=color:#66d9ef>u32</span>)),
</span></span></code></pre></div><p>We&rsquo;ll also need to extend the expression evaluator to handle this case:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>evaluate_expression</span>(expr: <span style=color:#a6e22e>EvalExpr</span>, context: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> EvalContext) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span>, anyhow::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> expr {
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        EvalExpr::SourceLine((src_module, src_file, src_line)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            resolve_source_line_to_address(<span style=color:#f92672>&amp;</span>src_module, <span style=color:#f92672>&amp;</span>src_file, src_line, context.process)
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>To implement <code>resolve_source_line_to_address</code>, we&rsquo;ll search through all compilation units to find any that reference the source file that we&rsquo;re looking at.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>resolve_source_line_to_address</span>(module_name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, src_file: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, src_line: <span style=color:#66d9ef>u32</span>, process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Process) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> modules <span style=color:#f92672>=</span> dbi.modules()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(module) <span style=color:#f92672>=</span> modules.next()<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(Some(mi)) <span style=color:#f92672>=</span> pdb.module_info(<span style=color:#f92672>&amp;</span>module) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(line_program) <span style=color:#f92672>=</span> mi.line_program() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> line_program_references_file(<span style=color:#f92672>&amp;</span>line_program, src_file, <span style=color:#f92672>&amp;</span>string_table)<span style=color:#f92672>?</span> {
</span></span></code></pre></div><p>The implementation of line_program_references_file is just a straight linear search through the list of files returned from the LineProgram (class provided by the pdb create).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_program_references_file</span>(line_program: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>LineProgram</span>, src_file: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, string_table: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>StringTable</span>) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> files <span style=color:#f92672>=</span> line_program.files();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(file) <span style=color:#f92672>=</span> files.next()<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> cur_file_name <span style=color:#f92672>=</span> string_table.get(file.name)<span style=color:#f92672>?</span>.to_string();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> cur_file_name <span style=color:#f92672>==</span> src_file {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Ok(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Ok(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For any compilation unit that references the source file in question, we&rsquo;ll search through the line mappings to find one that matches. There are faster ways of doing this search, but I don&rsquo;t see an easy way to do better than a linear search with the pdb crate. But it&rsquo;s fast enough for our purposes and is fairly easy to read.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> line_program.lines();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(line) <span style=color:#f92672>=</span> lines.next()<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> cur_file_name_ref <span style=color:#f92672>=</span> line_program.get_file_info(line.file_index)<span style=color:#f92672>?</span>.name;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> cur_file_name <span style=color:#f92672>=</span> string_table.get(cur_file_name_ref)<span style=color:#f92672>?</span>.to_string();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> cur_file_name <span style=color:#f92672>==</span> src_file <span style=color:#f92672>&amp;&amp;</span> line.line_start <span style=color:#f92672>&lt;=</span> src_line <span style=color:#f92672>&amp;&amp;</span> src_line <span style=color:#f92672>&lt;=</span> line.line_end {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> rva <span style=color:#f92672>=</span> line.offset.to_rva(<span style=color:#f92672>&amp;</span>address_map).ok_or(anyhow!(<span style=color:#e6db74>&#34;Could not map source entry to RVA&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> address <span style=color:#f92672>=</span> process_module.address <span style=color:#f92672>+</span> rva.<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> Ok(address);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span></code></pre></div><p>It&rsquo;s important to note again that the mapping from source line to address is not a one-to-one mapping. A single source line nearly always compiles to multiple assembly instructions. So in this case we&rsquo;re returning the first instruction in that block of instructions (which is typically what you want for a breakpoint). The instructions that result from a single line of code being compiled are also not necessarily contiguous, so you could have a few assembly instructions for line 1, a few instructions for line 2, and then some more for line 1 again. And beyond that, there&rsquo;s also cases where a function gets inlined, so a single source line can map to hundreds or thousands of addresses! For the sake of simplicity, we&rsquo;ll ignore all of that and simply return the first match we find. In a <em>real</em> debugger, you could not ignore that problem or you would have very unhappy users!</p><p>Now that we can resolve source lines to addresses and vice versa, we can easily test that we can &ldquo;round-trip&rdquo; a source line to an address and back to a source line.</p><pre tabindex=0><code>&gt; lsa `hello!C:\git\HelloWorld\hello.cpp:35`  
LSA: C:\git\HelloWorld\hello.cpp:35
Found matching file: C:\git\HelloWorld\hello.cpp
   33: 
   34: int main()
&gt;  35: {
   36:     printf(&#34;Hello world, %d&#34;, func1());
   37:     printf(&#34;Hello world 2!&#34;);
</code></pre><p>It works! We can even set breakpoints using this:</p><pre tabindex=0><code>&gt; bp `hello!C:\git\HelloWorld\hello.cpp:37`  
[6DE8] 0x00007ffb0ebaaa20
&gt; bl
  0 0x00007ff7f8f27207 (hello.exe!main+0x17)
[6DE8] 0x00007ffb0ebaaa20
</code></pre><p>That&rsquo;s a big step towards being useful for people that want to do more than read assembly code! But unfortunately, all of our data is still in registers and memory, so we&rsquo;re still not a &ldquo;source level&rdquo; debugger yet. That will have to be the next project, which will use the symbolic information to show information about local variables, with names and type information.</p><p>Hope you enjoyed this post about DbgRs! Have a question or suggestion? Let me know! You can find me on <a href=https://twitter.com/timmisiak>Twitter</a>, <a href=https://dbg.social/@tim>Mastodon</a>, and <a href=https://bsky.app/profile/timdbg.com>Bluesky</a>.</p><footer><h2 id=footnote-label>Footnotes</h2><ol><li id=dbg-files>The original .DBG format dates <a href=https://web.archive.org/web/20160324115412/https://support.microsoft.com/en-us/kb/121366>back to the DOS days</a>, when debugging information could not be appended directly to a .COM file, as this sort of executable file was loaded directly into memory and had to be smaller than 64K. So to provide debug information for .COM files, a separate .DBG file could be generated alongside the .COM file. Even back then, the debugging information was known as CodeView. I'm not sure if it has anything in common with the newer format sharing the same name.</li><li id=llvm-pdb-docs>A good high level overview that goes into more depth is availbe in the <a href=https://llvm.org/docs/PDB/index.html>LLVM documentation for PDB files</a>. It's not exhaustive documentation, but it's a good starting point and was a reference I used when writing this blog post as well as a project I had to re-implement the pdbstr utility. There are <a href=https://github.com/llvm/llvm-project/issues/76602>some errors</a> and probably isn't actively being updated, but it's still the most accessible place to start.</li><li id=named-streams>Any arbitrary named stream can be added to a PDB file using the <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/the-pdbstr-tool>pdbstr.exe tool</a>. This functionality is what allowed the original <a href=https://learn.microsoft.com/en-us/windows/win32/debug/source-server-and-source-indexing>"Source Indexing"</a> functionality to work, and is also used by the newer <a href=https://github.com/dotnet/sourcelink/blob/main/README.md>"Source Link"</a> format, both of which allow embedding information in a PDB file for locating the original version of a source file from a source repository or other server.</li><li id=codeview-records>The records in the symbol table are sometimes just called "symbols", but I typically try to call them "symbol records" or "codeview records" because the term "symbol" is too overloaded of a term.</li><li id=other-eval-changes>You might notice that I also changed the evaluator to work with module names with the extension omitted. This matches the windbg behavior (and thus my muscle memory).</li><li id=faster-source-lookups>If I remember correctly, there is a faster way to lookup symbols than enumerating every module, as the PDB file has some embedded hash tables for direct lookup. Using a higher level mechanism like <a href="https://learn.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/debug-interface-access-sdk?view=vs-2022">DIA</a> would probably use the embedded hashtables where possible (e.g. when not doing a pattern-based search). Similarly for source files, I believe there is a faster way to do the lookup for the correct module but the brute force way seems fast enough for our purposes and is pretty easy to understand. At least the operation for each module is fast, since lines_for_symbol is a binary search.</li><li id=code-to-line-duplicates>You could actually have a single code address that corresponds to multiple source locations if the <a href="https://devblogs.microsoft.com/oldnewthing/20050322-00/?p=36113">linker/optimizer combines multiple functions together</a> because they had the same generated code. In most cases, there's not a good way to show this in an interactive debugger, and WinDbg in particular handles this by just showing a single source resolution. That can be particularly confusing when you set a source level breakpoint in one place but it gets displayed on a completely different source line! Especially when the relationship between those two functions isn't clear. When I worked on WinDbg, I always wanted to do better for these cases by trying to use more context clues to figure out a more specific resolution (e.g. when resolving an address in a call stack, determine what function was originally called and use that version), but in reality the functions that get folded together are <i>usually</i> fairly trivial.</li><li id=source-file-info>WinDbg will keep track of what module each source file was loaded from, which allows it to search only that module for breakpoint resolution. A source file that was loaded from an address (like one that you navigate to from a call stack) will have this module assocation, but a file opened directly (e.g. from the "open source file" dialog) will not. This can cause *drastically* different performance for breakpoint resolution because setting a breakpoint on a source file without an associated module will end up needing to search through every single loaded module to find a breakpoint resolution! We could implement support for optionally searching through all modules, but that's easy enough to add later.</li></ol></footer></div><div class=post-footer></div></article></main></body></html>