<!doctype html><html lang=en-us><head><title>Writing a Debugger From Scratch - DbgRs Part 6 - Stacks // TimDbg</title>
<link rel="shortcut icon" href=WinDbg.ico><meta charset=utf-8><meta name=generator content="Hugo 0.120.4"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Tim Misiak"><meta name=description content><link rel=stylesheet href=/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><link rel=stylesheet href=/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZF3NN3CLRX"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZF3NN3CLRX",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing a Debugger From Scratch - DbgRs Part 6 - Stacks"><meta name=twitter:description content="(New to this series? Consider starting from part 1)
At the end of the last post, DbgRs could finally set breakpoints. That was the last really critical feature needed for controlling execution of a program. Now that it can stop on an arbitrary function or code location, the next step is to find more information about the state of the program. In my opinion, the single most useful piece of information is the call stack, so that&rsquo;s what this post will be about."><meta property="og:title" content="Writing a Debugger From Scratch - DbgRs Part 6 - Stacks"><meta property="og:description" content="(New to this series? Consider starting from part 1)
At the end of the last post, DbgRs could finally set breakpoints. That was the last really critical feature needed for controlling execution of a program. Now that it can stop on an arbitrary function or code location, the next step is to find more information about the state of the program. In my opinion, the single most useful piece of information is the call stack, so that&rsquo;s what this post will be about."><meta property="og:type" content="article"><meta property="og:url" content="/posts/writing-a-debugger-from-scratch-part-6/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-22T09:40:45-08:00"><meta property="article:modified_time" content="2023-11-22T09:40:45-08:00"><link rel=alternate type=application/rss+xml href=/index.xml title=TimDbg></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Tim Misiak"></a><h1>TimDbg</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>About</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>The art and science of debugging. And other stuff like that. From a former developer on WinDbg and the VMware hypervisor.</p><div class=app-header-social><a href=https://github.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/timmisiak target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.youtube.com/channel/UCyQ7p63-9V9PZJvgHLKgsaw target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube"><title>YouTube</title><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Writing a Debugger From Scratch - DbgRs Part 6 - Stacks</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Nov 22, 2023</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>25 min read</div></div></header><div class=post-content><p>(New to this series? Consider starting from <a href=/posts/writing-a-debugger-from-scratch-part-1>part 1</a>)</p><p>At the end of the <a href=/posts/writing-a-debugger-from-scratch-part-5>last post</a>, DbgRs could finally set breakpoints. That was the last really critical feature needed for controlling execution of a program. Now that it can stop on an arbitrary function or code location, the next step is to find more information about the state of the program. In my opinion, the single most useful piece of information is the call stack, so that&rsquo;s what this post will be about. Walking call stacks is the most complicated piece of DbgRs so far, and as such this post is somewhat longer than the others. Stick through to the end, though, it&rsquo;s worth the payoff! To keep this post as readable as I can, I&rsquo;ve used footnotes for anything that isn&rsquo;t strictly needed to understand how the stack walking works.</p><p>The code for this post is in the <a href=https://github.com/TimMisiak/dbgrs/tree/part6>part6 branch on github</a>. You can also view the <a href=https://github.com/TimMisiak/dbgrs/compare/part5...part6>changes from part5</a>. If you see any mistakes or ways to improve the code, feel free to <a href=https://github.com/TimMisiak/dbgrs/issues>create issues</a> on the GitHub repo or submit a PR. I&rsquo;ve had a few folks contribute changes and I really appreciate it!</p><h1 id=what-is-a-stack-frame>What IS a stack frame?</h1><p>When we talk about a <em>call stack</em> (sometimes called backtrace), what we&rsquo;re actually talking about are a stack of <em>frames</em> for a thread. You can think of a frame as the state of a function as it is executing. If function A calls function B, then function A needs to save its state (like local variables) somewhere so that when function B returns, function A can continue executing where it left off. In most cases, this state is saved on a stack. While each frame contains local variables, they also contain the <em>return address</em>, which is the next instruction to be executed when a function returns from a call. When a debugger displays a stack trace, it is enumerating the frames to find the list of return addresses and local variables from each frame. And in reality, both the instruction pointer and local variables are determined from a <em>register context</em>, so we can think of the stack walk as starting with the register context for a thread as the &ldquo;top&rdquo; of the stack, and repeatedly &ldquo;unwinding&rdquo; that register context to get the register context of the calling function.</p><p>So the fundamental operation we need to implement is to take a register context and the memory of a process and transform that into the register context of the calling function. Start with the &ldquo;top&rdquo; of the stack, which is just the current context of a thread, and apply this <a aria-describedby=footnote-label href=#unwind-or-walk>&ldquo;stack walk&rdquo;</a> operation repeatedly (printing the names of each function we find at RIP), and we have our basic stack walk!</p><h1 id=frame-pointers>Frame pointers</h1><p>So how do we walk from one frame to the next? For those of you that have taken an operating systems class, you might be thinking &ldquo;use frame pointers!&rdquo;. So then, what is a frame pointer? While the stack pointer (RSP) points to the &ldquo;top&rdquo; of the stack, the frame pointer (RBP) points to the start of the current function&rsquo;s frame. Using a frame pointer means we can find all of the local variables and other saved state for a function call as constant offsets from RBP.</p><p>A stack pointer is used for tracking the location of the last data that was &ldquo;pushed&rdquo; on the stack, and a frame pointer tracks the start of the stack for a function call, also know as the function&rsquo;s &ldquo;frame&rdquo;. A frame contains all of the data for the invocation of a function, potentially including locals, arguments, and saved copies of <a aria-describedby=footnote-label href=#nonvolatile-registers>nonvolatile registers</a>. Local variables are referenced as constant offsets to the frame pointer.</p><p>When a function uses frame pointers, the first few instructions will push the frame pointer onto the stack, and then set up the new frame pointer with the current stack pointer with some code that might look something like <a aria-describedby=footnote-label href=#frame-pointer>this</a>.</p><pre tabindex=0><code>00007ffa`7144b824 55              push    rbp
00007ffa`7144b825 488bec          mov     rbp,rsp
</code></pre><p>When returning from the function, the caller&rsquo;s base pointer is popped off the stack, and then execution is returned with a &lsquo;ret&rsquo;.</p><pre tabindex=0><code>00007ffa`7144b824 5d              pop     rbp
00007ffa`7144b825 c3              ret
</code></pre><p>When every function does this, the frame pointers form a linked list, with the return address immediately preceding the frame pointer on the stack. This makes it very easy to walk the list on the stack, using the current frame pointer (EBP on x86) as the head pointer of the list.</p><p><img src=/frame_pointers.png alt="Following frame pointers"></p><p>If everyone used frame pointers, this blog post would be <em>extremely</em> short. But if you&rsquo;ve glanced at your scroll bar, you&rsquo;ve figured out that frame pointers aren&rsquo;t the end of the story. And that&rsquo;s because of a little thing called &ldquo;Frame Pointer Omission&rdquo; (FPO).</p><p>In a typical function that allocates a static amount of memory on the stack, the frame pointer is redundant. The compiler knows that a function consumes N bytes of stack, so it adds N to the stack pointer when returning, and all locals can be referenced relative to the stack pointer instead of a frame pointer. And if some part of a function uses some additional stack, such as pushing parameters onto the stack for another function, the compiler can still determine <strong>at compile time</strong> how the offsets of these local variables shift at each instruction of the function. By referencing locals off the stack pointer instead of a frame pointer, it means that an entire register is freed up to be used for <a aria-describedby=footnote-label href=#fpo-speed>other purposes</a>. On Windows, nearly all <del>64-bit</del> x64 code is compiled with FPO enabled. (CORRECTION: As <a href=https://twitter.com/aaronsgiles/status/1727506942787199015>Aaron Giles points out</a>, FPO is off by default on ARM64, so this is specific to x64, not all 64-bit Windows code)</p><p>That&rsquo;s a problem for diagnostic tools that want to do stack walks, because they can no longer determine the location of the return address or calling function&rsquo;s frame address from a frame pointer. Luckily, there&rsquo;s a solution.</p><h1 id=the-pdata-section>The &ldquo;.pdata&rdquo; section</h1><p>What makes FPO possible is that compilers always know the size of a frame at a given instruction. It lets the compiler generate offsets to local variables correctly, and it also lets the compiler generate a correct prolog of a function to correctly return to the caller. So to enable diagnostic tools (and exception handling) to do the same thing, this information is stored <em>with</em> an executable file! On Windows, this data is stored in a section called &ldquo;.pdata&rdquo;. Since the OS uses this information for exception handling, much of the documentation can be found in the <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170">MSDN docs for exception handling</a>. The &ldquo;.pdata&rdquo; section does not exist for 32-bit x86 executables, and I won&rsquo;t be discussing here how stack walking works for 32-bit x86 code (short version: it&rsquo;s messy).</p><p>So let&rsquo;s take a short tour of what pdata looks like using WinDbg to examine the data. We&rsquo;ll start a debugging session of an x64 process and take a look at the pdata for kernel32. I&rsquo;m using cmd.exe here, but any x64 process should work. We can use the &ldquo;!dh&rdquo; extension command (Dump Header) as our starting point.</p><pre tabindex=0><code>0:000&gt; !dh kernel32

File Type: DLL
FILE HEADER VALUES
    8664 machine (X64)
       7 number of sections
D05C34F8 time date stamp Wed Oct  9 05:50:00 2080

...

   C2000 [     520] address [size] of Resource Directory
   BB000 [    5508] address [size] of Exception Directory
   C3000 [    4160] address [size] of Security Directory

...

SECTION HEADER #4
  .pdata name
    5508 virtual size
   BB000 virtual address
    6000 size of raw data
   BA000 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
40000040 flags
         Initialized Data
         (no align specified)
         Read Only
</code></pre><p>Note the address of the &ldquo;Exception Directory&rdquo; and the address of the &ldquo;.pdata&rdquo; section are both 0xBB000. These are both names for the same data, although the Exception Directory is the authorative source here. If we dump data at that address, we see a collection of <a href=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-runtime_function>RUNTIME_FUNCTION</a> structures.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_IMAGE_RUNTIME_FUNCTION_ENTRY</span> {
</span></span><span style=display:flex><span>  DWORD BeginAddress;
</span></span><span style=display:flex><span>  DWORD EndAddress;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>    DWORD UnwindInfoAddress;
</span></span><span style=display:flex><span>    DWORD UnwindData;
</span></span><span style=display:flex><span>  } DUMMYUNIONNAME;
</span></span><span style=display:flex><span>} RUNTIME_FUNCTION, <span style=color:#f92672>*</span>PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, <span style=color:#f92672>*</span>_PIMAGE_RUNTIME_FUNCTION_ENTRY;
</span></span></code></pre></div><pre tabindex=0><code>0:000&gt; dd kernel32+BB000
00007ffa`2bf9b000  00001010 0000115a 00098428 00001160
00007ffa`2bf9b010  0000119f 00098444 00001210 00001406
00007ffa`2bf9b020  0009844c 00001440 00001613 00098470
</code></pre><p>Each structure is a 32-bit offset to the start of a function (relative to the base address), followed by a 32-bit offset to the end of the function (one byte past the end actually), and finally a 32-bit offset to the unwind data itself. The structures are packed together, so you can see a pattern repeated every three dwords. If you look closely, you&rsquo;ll also see that the &ldquo;BeginAddress&rdquo; field is increasing for each entry, meaning that this table is sorted. We&rsquo;ll focus on the first entry in this table, which is the first three dwords.</p><pre tabindex=0><code>0:000&gt; dd kernel32+BB000 L3
00007ffa`2bf9b000  00001010 0000115a 00098428
</code></pre><p>That gives us a BeginAddress of 0x1010, an EndAddress of 0x115a, and an UnwindInfoAddress of 0x98428. Adding the module base address to the BeginAddress gives us the address of the function this entry is annotating, which happens to be kernel32!Module32NextW.</p><pre tabindex=0><code>0:000&gt; u kernel32+00001010
KERNEL32!Module32NextW:
00007ffa`2bee1010 4c8bdc          mov     r11,rsp
00007ffa`2bee1013 49895b08        mov     qword ptr [r11+8],rbx
00007ffa`2bee1017 57              push    rdi
00007ffa`2bee1018 4883ec50        sub     rsp,50h
00007ffa`2bee101c 33ff            xor     edi,edi
</code></pre><p>Using the UnwindInfoAddress of 0x98428, we can find the <strong>unwind data</strong> which contains the information we need to unwind this function. The data stored here is described by the <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170">UNWIND_INFO structure</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_UNWIND_INFO</span> {
</span></span><span style=display:flex><span>    UBYTE Version       : <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    UBYTE Flags         : <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    UBYTE SizeOfProlog;
</span></span><span style=display:flex><span>    UBYTE CountOfCodes;
</span></span><span style=display:flex><span>    UBYTE FrameRegister : <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    UBYTE FrameOffset   : <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    UNWIND_CODE UnwindCode[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span><span style=color:#75715e>/*  UNWIND_CODE MoreUnwindCode[((CountOfCodes + 1) &amp; ~1) - 1];
</span></span></span><span style=display:flex><span><span style=color:#75715e>*   union {
</span></span></span><span style=display:flex><span><span style=color:#75715e>*       OPTIONAL ULONG ExceptionHandler;
</span></span></span><span style=display:flex><span><span style=color:#75715e>*       OPTIONAL ULONG FunctionEntry;
</span></span></span><span style=display:flex><span><span style=color:#75715e>*   };
</span></span></span><span style=display:flex><span><span style=color:#75715e>*   OPTIONAL ULONG ExceptionData[]; */</span>
</span></span><span style=display:flex><span>} UNWIND_INFO, <span style=color:#f92672>*</span>PUNWIND_INFO;
</span></span></code></pre></div><p>We can dump the memory for this structure using <code>db</code></p><pre tabindex=0><code>0:000&gt; db kernel32+98428
00007ffa`2bf78428  01 0c 04 00 0c 34 0c 00-0c 92 08 70 21 00 00 00  .....4.....p!...
</code></pre><p>This data is a bit harder to decode by hand, but I&rsquo;ll point out the interesting values here. The first byte is a combination of version and flags. Version is always 1, according to the docs, but the flags can have the following values:</p><table><thead><tr><th>Name</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td><code>UNW_FLAG_NHANDLER</code></td><td><code>0x0</code></td><td>The function has no handler.</td></tr><tr><td><code>UNW_FLAG_EHANDLER</code></td><td><code>0x1</code></td><td>The function has an exception handler that should be called.</td></tr><tr><td><code>UNW_FLAG_UHANDLER</code></td><td><code>0x2</code></td><td>The function has a termination handler that should be called when unwinding an exception.</td></tr><tr><td><code>UNW_FLAG_CHAININFO</code></td><td><code>0x4</code></td><td>The FunctionEntry member is the contents of a previous function table entry.</td></tr></tbody></table><p>For this entry, there are no flags set. For the purposes of walking the call stack, we can ignore exception handlers, although eventually we will need to handle. The next value is SizeOfProlog, which is 0xC. Looking at the disassembly again, and we can see this corresponds to the address of the first instruction after the &ldquo;sub rsp, 50h&rdquo; instruction:</p><pre tabindex=0><code>0:000&gt; u kernel32+00001010
KERNEL32!Module32NextW:
00007ffa`2bee1010 4c8bdc          mov     r11,rsp
00007ffa`2bee1013 49895b08        mov     qword ptr [r11+8],rbx
00007ffa`2bee1017 57              push    rdi
00007ffa`2bee1018 4883ec50        sub     rsp,50h
00007ffa`2bee101c 33ff            xor     edi,edi
</code></pre><p>The third byte is CountOfCodes, which is 0x4 here. We&rsquo;ll look at that more in a moment. Finally, the fourth byte indicates which frame register is used (if any) and what offset to apply (if any). Here, the value is zero, which means that no frame register is used.</p><h1 id=unwind-codes>Unwind codes</h1><p>Immediately following the UNWIND_INFO structure are the &ldquo;unwind codes&rdquo;. These describe the operations in the prolog, and can be used to &ldquo;undo&rdquo; the state of the prolog, getting the state of a stack and context back to the <a aria-describedby=footnote-label href=#initial-state>initial state</a> when the function was called, making it possible to find the return address and register state for the caller. While the <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170#struct-unwind_code">UNWIND_CODE</a> structure is 16 bits, some operations consume multiple &ldquo;slots&rdquo;. The &ldquo;count of codes&rdquo; field from UNWIND_INFO actually describes the number of slots consumed, rather than the number of operations. Here&rsquo;s the C description of the codes, taken from the documentation page:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>_UNWIND_OP_CODES</span> {
</span></span><span style=display:flex><span>    UWOP_PUSH_NONVOL <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#75715e>/* info == register number */</span>
</span></span><span style=display:flex><span>    UWOP_ALLOC_LARGE,     <span style=color:#75715e>/* no info, alloc size in next 2 slots */</span>
</span></span><span style=display:flex><span>    UWOP_ALLOC_SMALL,     <span style=color:#75715e>/* info == size of allocation / 8 - 1 */</span>
</span></span><span style=display:flex><span>    UWOP_SET_FPREG,       <span style=color:#75715e>/* no info, FP = RSP + UNWIND_INFO.FPRegOffset*16 */</span>
</span></span><span style=display:flex><span>    UWOP_SAVE_NONVOL,     <span style=color:#75715e>/* info == register number, offset in next slot */</span>
</span></span><span style=display:flex><span>    UWOP_SAVE_NONVOL_FAR, <span style=color:#75715e>/* info == register number, offset in next 2 slots */</span>
</span></span><span style=display:flex><span>    UWOP_SAVE_XMM128 <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, <span style=color:#75715e>/* info == XMM reg number, offset in next slot */</span>
</span></span><span style=display:flex><span>    UWOP_SAVE_XMM128_FAR, <span style=color:#75715e>/* info == XMM reg number, offset in next 2 slots */</span>
</span></span><span style=display:flex><span>    UWOP_PUSH_MACHFRAME   <span style=color:#75715e>/* info == 0: no error-code, 1: error-code */</span>
</span></span><span style=display:flex><span>} UNWIND_CODE_OPS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> UBYTE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> <span style=color:#a6e22e>_UNWIND_CODE</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        UBYTE CodeOffset;
</span></span><span style=display:flex><span>        UBYTE UnwindOp : <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>        UBYTE OpInfo   : <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    USHORT FrameOffset;
</span></span><span style=display:flex><span>} UNWIND_CODE, <span style=color:#f92672>*</span>PUNWIND_CODE;
</span></span></code></pre></div><p>The UNWIND_INFO structure is 4 bytes, so we can add 4 to the UnwindInfoAddress to get the array of unwind codes. As we determined from the CountOfCodes field, there are 4 slots. Each slot is 16 bits, so we&rsquo;ll dump the next 8 bytes.</p><pre tabindex=0><code>0:000&gt; db kernel32+98428+4 L8
00007ffa`2bf7842c  0c 34 0c 00 0c 92 08 70                          .4.....p
</code></pre><p>The first code here &ldquo;0C 34&rdquo; has an offset of 0xC, an unwind operation of 0x4, and an &ldquo;OpInfo&rdquo; field of 0x3. Operation 4 is UWOP_SAVE_NONVOL, so the OpInfo field corresponds to the register being saved, which for 0x3 <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170#operation-info">corresponds to RBX</a>. For UWOP_SAVE_NONVOL, the subsequent slot is used as the offset from the stack pointer (scaled by 8, since all access is 64-bit aligned). The 16-bit value following the first slot is 0xC (remember, this is little endian so 0C 00 bytes become 0x000C as a 16-bit value). Scaling by 8, we get 0xC * 8 == 0x60. Looking at the prolog again you can see RBX is saved to the stack as the second instruction in the prolog at offset RSP+8. With the other operations of the prolog updating RSP, the address of this location ends up being RSP+0x60. See the annotated assembly below to see how this happens.</p><pre tabindex=0><code>0:000&gt; u kernel32+00001010 L6
KERNEL32!Module32NextW:
00007ffa`2bee1010 4c8bdc          mov     r11,rsp                # Copies RSP into R11
00007ffa`2bee1013 49895b08        mov     qword ptr [r11+8],rbx  # Writes RBX to the stack at [RSP+8]
00007ffa`2bee1017 57              push    rdi                    # Decrements RSP by 8, so RBX is now at [RSP+0x10]
00007ffa`2bee1018 4883ec50        sub     rsp,50h                # Decrements RSP by 0x50, so RBX is now at [RSP+0x60]
00007ffa`2bee101c 33ff            xor     edi,edi                # This is offset 0xC into the function
00007ffa`2bee101e 488bda          mov     rbx,rdx                # This is where the original RBX is overwritten
</code></pre><p>Decoding these by hand is <strong>exhausting</strong>, but luckily there&rsquo;s an easy shortcut when using WinDbg. The <code>.fnent</code> command will decode all of the unwind operations in an easy to read format!</p><pre tabindex=0><code>0:000&gt; .fnent kernel32!Module32NextW
Debugger function entry 000001cb`f8df4aa0 for:
(00007ffa`2bee1010)   KERNEL32!Module32NextW   |  (00007ffa`2bee1160)   KERNEL32!ThpCopyAnsiToUnicode
Exact matches:
    KERNEL32!Module32NextW (void)

BeginAddress      = 00000000`00001010
EndAddress        = 00000000`0000115a
UnwindInfoAddress = 00000000`00098428

Unwind info at 00007ffa`2bf78428, c bytes
  version 1, flags 0, prolog c, codes 4
  00: offs c, unwind op 4, op info 3	UWOP_SAVE_NONVOL FrameOffset: 60 reg: rbx.
  02: offs c, unwind op 2, op info 9	UWOP_ALLOC_SMALL.
  03: offs 8, unwind op 0, op info 7	UWOP_PUSH_NONVOL reg: rdi.
</code></pre><p>The operations are listed in reverse order, which is very convenient when unwinding the stack, since the operations need to be applied in reverse order to reverse the operations of the prolog. Unwinding the stack while in the middle of a prolog is also possible. We just need to skip any of the unwind operations that occur after the current instruction.</p><h2 id=what-about-the-epilog>What about the epilog???</h2><p>It might seem strange to you that we have so much metadata about the prolog, but nothing about the epilog! If code is currently executing in the middle of an epilog, we don&rsquo;t know which prolog operations have already been reversed, so attempting to follow the unwind operations could get us into a completely bogus state. And the answer might be a little surprising. To unwind the stack while in an epilog, we need to <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170#unwind-procedure">read the code stream</a> to determine if we are in an epilog, and if so, we simply emulate the remaining portion of the epilog. This is feasible only because epilogs have <a href="https://learn.microsoft.com/en-us/cpp/build/prolog-and-epilog?view=msvc-170#epilog-code">very strict rules</a> that make it easy to detect and simulate epilogs. The epilog must always:</p><ol><li>Deallocate the &ldquo;fixed part&rdquo; of the stack</li><li>Pop all nonvolatile registers</li><li>Return control to the caller (via &ldquo;ret&rdquo;)</li></ol><p>The deallocation of the fixed part of the stack must only use an <code>ADD</code> or <code>LEA</code> instruction, and the nonvolatile pops must use the <code>POP &lt;reg></code> instructions. To detect an epilog, we start reading code bytes and stop if we ever hit an instruction that is not legal inside an epilog or if we hit a <code>ret</code> instruction. Hitting a <code>ret</code> before any instructions invalid for an epilog means the current instruction is in a valid epilog.</p><h1 id=unwinding-the-context-in-dbgrs>Unwinding the context in DbgRs</h1><p>All of this is enough information for us to unwind a register context. Our main function will simply be called &ldquo;unwind_context&rdquo; and will take a context and optionally return a new context if a calling frame is found. We need to include memory (for reading the stack) and the process information where we keep track of modules.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>unwind_context</span>(process: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Process, context: <span style=color:#a6e22e>CONTEXT</span>, memory_source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource) -&gt; Result<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>CONTEXT</span><span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span></code></pre></div><p>If we find a module for the instruction pointer, we&rsquo;ll use that to find the &ldquo;exception&rdquo; directory where the function table lives.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> module <span style=color:#f92672>=</span> process.get_containing_module_mut(context.Rip);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(module) <span style=color:#f92672>=</span> module {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> data_directory <span style=color:#f92672>=</span> module.get_data_directory(<span style=color:#66d9ef>IMAGE_DIRECTORY_ENTRY_EXCEPTION</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> data_directory.VirtualAddress <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> data_directory.Size <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> count <span style=color:#f92672>=</span> data_directory.Size <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>/</span> std::mem::size_of::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>RUNTIME_FUNCTION</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> table_address <span style=color:#f92672>=</span> module.address <span style=color:#f92672>+</span> data_directory.VirtualAddress <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Note: In a real debugger you might want to cache these.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> functions: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>RUNTIME_FUNCTION</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> read_memory_full_array(memory_source, table_address, count)<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>All of the <code>RUNTIME_FUNCTION</code> entries describe functions as relative virtual address, which are relative to the module base. So we&rsquo;ll subtract the module base to get the rva of our instruction pointer. From there, we can do a search of the table, which can be done using a binary search bcause the functions entries are always in order. (The implementation of <a href=https://github.com/TimMisiak/dbgrs/blob/part6/src/stack.rs#L65>find_runtime_function is here</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            <span style=color:#66d9ef>let</span> rva <span style=color:#f92672>=</span> context.Rip <span style=color:#f92672>-</span> module.address;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> func <span style=color:#f92672>=</span> find_runtime_function(rva <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>, <span style=color:#f92672>&amp;</span>functions);
</span></span></code></pre></div><p>If we find a match, we&rsquo;ll read the unwind info and operations so we can apply them to the context. Once we&rsquo;ve parsed out the information from the main UNWIND_INFO structure, we can use the UNWIND_INFO::count_of_codes field to determine how many 16-bit codes should be read. Remember that this isn&rsquo;t the number of operations, as many operations take multiple &ldquo;code slots&rdquo;. Once we have the Vec of u16 codes, we&rsquo;ll pass it to <code>get_unwind_ops</code> which will convert the codes into the Vec of logical operations.</p><p>Note that I&rsquo;m using a macro here called <code>split_up!</code> which I made to simplify breaking up bitfields. The version_flags field, for instance, is equivalent to the bitfields for the version and flags fields of <code>UNWIND_INFO</code> and can be split using <code>split_up!(info.version_flags => 3, 5)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(func) <span style=color:#f92672>=</span> func {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// We have unwind data!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> info_addr <span style=color:#f92672>=</span> module.address <span style=color:#f92672>+</span> func.UnwindInfo <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> info <span style=color:#f92672>=</span> read_memory_data::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>UNWIND_INFO</span><span style=color:#f92672>&gt;</span>(memory_source, info_addr)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> (_version, flags) <span style=color:#f92672>=</span> split_up!(info.version_flags <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> (frame_register, frame_offset) <span style=color:#f92672>=</span> split_up!(info.frame_register_offset <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> frame_offset <span style=color:#f92672>=</span> (frame_offset <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u16</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>16</span>;
</span></span><span style=display:flex><span>                <span style=color:#75715e>// The codes are UNWIND_CODE, but we&#39;ll have to break them up in different ways anyway based on the operation, so we might as well just
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// read them as u16 and then parse out the fields as needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> codes <span style=color:#f92672>=</span> read_memory_full_array::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u16</span><span style=color:#f92672>&gt;</span>(memory_source, info_addr <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>, info.count_of_codes <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> unwind_ops <span style=color:#f92672>=</span> get_unwind_ops(<span style=color:#f92672>&amp;</span>codes, frame_register, frame_offset)<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>While there are 9 different <code>UWOP_*</code> constants, many of these are just different encodings for the same logical operations, so there are really only 6 operations we need to handle after we&rsquo;ve parsed the unwind codes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>UnwindOp</span> {
</span></span><span style=display:flex><span>    PushNonVolatile { reg: <span style=color:#66d9ef>u8</span> },
</span></span><span style=display:flex><span>    Alloc { size: <span style=color:#66d9ef>u32</span> },
</span></span><span style=display:flex><span>    SetFpreg { frame_register: <span style=color:#66d9ef>u8</span>, frame_offset: <span style=color:#66d9ef>u16</span> },
</span></span><span style=display:flex><span>    SaveNonVolatile { reg: <span style=color:#66d9ef>u8</span>, offset: <span style=color:#66d9ef>u32</span> },
</span></span><span style=display:flex><span>    SaveXmm128 { reg: <span style=color:#66d9ef>u8</span>, offset: <span style=color:#66d9ef>u32</span> },
</span></span><span style=display:flex><span>    PushMachFrame { error_code: <span style=color:#66d9ef>bool</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Parsing the codes into an array of <code>UnwindOp</code>s is straightforward, but needs to account for the variable length encoding. Each operation starts with a 16 bit code slot that describes the offset (from the beginning of the function), an operation, and an &ldquo;info&rdquo; field that gets interpreted in different ways depending on the operation. (Full code for <a href=https://github.com/TimMisiak/dbgrs/blob/part6/src/stack.rs#L102>get_unwind_ops is here</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_unwind_ops</span>(code_slots: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u16</span>], frame_register: <span style=color:#66d9ef>u8</span>, frame_offset: <span style=color:#66d9ef>u16</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>UnwindCode<span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ops <span style=color:#f92672>=</span> Vec::<span style=color:#f92672>&lt;</span>UnwindCode<span style=color:#f92672>&gt;</span>::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> code_slots.len() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (code_offset, unwind_op, op_info) <span style=color:#f92672>=</span> split_up!(code_slots[i] <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> code_offset <span style=color:#f92672>=</span> code_offset <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> unwind_op <span style=color:#f92672>=</span> unwind_op <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> op_info <span style=color:#f92672>=</span> op_info <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span></code></pre></div><p>Now we can have a big &ldquo;match&rdquo; to map the codes to the logical operations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=color:#66d9ef>match</span> unwind_op {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>UWOP_PUSH_NONVOL</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                ops.push(UnwindCode { code_offset, op: <span style=color:#a6e22e>UnwindOp</span>::PushNonVolatile { reg: <span style=color:#a6e22e>op_info</span> } });
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>For operations that take multiple code slots, we&rsquo;ll check that we have enough code slots left and increment the index to account for the slots consumed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            <span style=color:#66d9ef>UWOP_SAVE_NONVOL</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> code_slots.len() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Err(<span style=color:#e6db74>&#34;UWOP_SAVE_NONVOL was incomplete&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> offset <span style=color:#f92672>=</span> code_slots[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span>                ops.push(UnwindCode { code_offset, op: <span style=color:#a6e22e>UnwindOp</span>::SaveNonVolatile { reg: <span style=color:#a6e22e>op_info</span>, offset } });
</span></span><span style=display:flex><span>                i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>Now that we have the list of logical unwind operations, we&rsquo;ll find <a aria-describedby=footnote-label href=#epilog-apply>the operations</a> that are applicable given the instruction pointer. Keep in mind that the unwind operations are described in terms of the &ldquo;forward operation&rdquo; of the prolog, and we need to execute the reverse of each of them. So for the &ldquo;Push&rdquo; operation, we&rsquo;ll pop a register. For the &ldquo;alloc&rdquo; operation, we&rsquo;ll deallocate space on the stack. Since the list of operations is already in reverse order we can iterate through the list and undo each operation. We <em>do</em> need to check the <code>code_offset</code> field to make sure that the operation has already been executed. If the current instruction is in the middle of the prolgue, we&rsquo;ll skip any unwind operations that haven&rsquo;t actually <a aria-describedby=footnote-label href=#taken-effect>taken effect yet</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>apply_unwind_ops</span>(context: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>CONTEXT</span>, unwind_ops: <span style=color:#66d9ef>&amp;</span>[UnwindCode], func_address: <span style=color:#66d9ef>u64</span>, memory_source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>dyn</span> MemorySource) -&gt; Result<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>CONTEXT</span><span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&amp;</span>&#39;static <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> unwound_context <span style=color:#f92672>=</span> context.clone();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> unwind <span style=color:#66d9ef>in</span> unwind_ops.iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> func_offset <span style=color:#f92672>=</span> unwound_context.Rip <span style=color:#f92672>-</span> func_address;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> unwind.code_offset <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span> <span style=color:#f92672>&lt;=</span> func_offset {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> unwind.op {
</span></span></code></pre></div><p>The UWOP_ALLOC_SMALL and UWOP_ALLOC_LARGE are both easy to reverse. Allocating memory on the stack means subtracting from the stack pointer. So deallocating is just adding to the stack pointer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                UnwindOp::Alloc { size } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    unwound_context.Rsp <span style=color:#f92672>+=</span> size <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><p>Similarly, to reverse a push, we need to pop a value. That means that we read the 64-bit value at the current RSP, <a aria-describedby=footnote-label href=#push-ordering>store it to the indicated register</a>, and then add 8 to the RSP. We&rsquo;ll have a helper function called <a href=https://github.com/TimMisiak/dbgrs/blob/part6/src/stack.rs#L178><code>get_op_register</code> that will map the numeric register value</a> to a u64 reference for the indicated register inside the unwound_context.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                UnwindOp::PushNonVolatile { reg } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> addr <span style=color:#f92672>=</span> unwound_context.Rsp;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> val <span style=color:#f92672>=</span> read_memory_data::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>(memory_source, addr)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>get_op_register(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> unwound_context, reg) <span style=color:#f92672>=</span> val;
</span></span><span style=display:flex><span>                    unwound_context.Rsp <span style=color:#f92672>+=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><p>A &ldquo;save nonvolatile&rdquo; operation is basically the same as a push except we don&rsquo;t need to worry about updating the stack pointer, so it&rsquo;s a bit simpler. This operation can have an offset, so we need to take that into account.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                UnwindOp::SaveNonVolatile { reg, offset } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> addr <span style=color:#f92672>=</span> unwound_context.Rsp <span style=color:#f92672>+</span> offset <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> val <span style=color:#f92672>=</span> read_memory_data::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>(memory_source, addr)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>get_op_register(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> unwound_context, reg) <span style=color:#f92672>=</span> val;
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><p>Finally, the UWOP_SET_FPREG operation is a bit different. This operation means that the frame pointer is assigned the value of RSP plus an offset. The register being &ldquo;saved&rdquo; is actually RSP (typically because RSP will change by a variable amount, such as by using alloca). So to reverse this operation, we need to restore RSP by subtracting the frame_offset from the current value of the frame pointer. The frame pointer doesn&rsquo;t have to be RBP, so we use get_op_register again.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                UnwindOp::SetFpreg { frame_register, frame_offset } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    unwound_context.Rsp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>get_op_register(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> unwound_context, frame_register) <span style=color:#f92672>-</span> (frame_offset <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Not implemented: UWOP_SAVE_XMM and UWOP_PUSH_MACFRAME
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;NYI unwind op&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Ok(Some(unwound_context))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Still with me? We&rsquo;re almost done! We&rsquo;ve rewound the prolog, but we still haven&rsquo;t rewound the &ldquo;CALL&rdquo; instruction that kicked everything off, so that will be the last step. This part is also the <em>only</em> thing we need to do in the case of a leaf function, so back in the unwind_context function we&rsquo;ll take care of both of those cases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ctx <span style=color:#f92672>=</span> ctx;
</span></span><span style=display:flex><span>    ctx.Rip <span style=color:#f92672>=</span> read_memory_data::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>(memory_source, ctx.Rsp)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    ctx.Rsp <span style=color:#f92672>+=</span> <span style=color:#ae81ff>8</span>;
</span></span></code></pre></div><p>And that&rsquo;s it! All we need now is a new debugger command that <a href=https://github.com/TimMisiak/dbgrs/blob/part6/src/main.rs#L228>repeatedly walks frames</a> using the unwind_context function and <a aria-describedby=footnote-label href=#when-to-stop>we&rsquo;re done</a>!</p><h1 id=testing-it-out>Testing it out</h1><p>Finally, we have a &ldquo;k&rdquo; command. Does it work?</p><pre tabindex=0><code>&gt; k
 #   RSP              Call Site
00 0x00000038E310FC48 hello.exe!func3+0x3
01 0x00000038E310FC50 hello.exe!func2+0x4A
02 0x00000038E310FD10 hello.exe!func1+0x9
03 0x00000038E310FD50 hello.exe!main+0x9
</code></pre><p>It does! It&rsquo;s certainly not perfect, as there are a lot of missing cases still. But one really important case we&rsquo;ve missed is how to unwind the stack when we&rsquo;re in the epilog. But to do that correctly, we need to be able to unassemble x64 instructions. And really, what good is a debugger if it can&rsquo;t show you assembly instructions? So I think you know what I&rsquo;ll be doing in the next part of this series.</p><p>This series has been building towards this for a while, and I hope those of you that have been reading along found this interesting! Have a question or suggestion? Let me know! You can find me on <a href=https://twitter.com/timmisiak>Twitter</a>, <a href=https://dbg.social/@tim>Mastodon</a>, and <a href=https://bsky.app/profile/timdbg.com>Bluesky</a>.</p><footer><h2 id=footnote-label>Footnotes</h2><ol><li id=unwind-or-walk>When talking about stacks, you're likely to hear both "unwinding" and "walking" when talking about traversing the frames of a stack. Which is correct? I occaisionally use these interchangably because they are closely related concepts, but in Windows lingo you'll see that "walk" usually refers to enumerating the frames of a stack, while "unwind" usually refers to *changing* the state of a thread in order to implement exception handling. That said, much of the metadata we will use to implement stack walking is also used for exception handling, so many of the constants and functions will reference "unwinding".</li><li id=nonvolatile-registers>Nonvolatile registers are registers that are expected to not be overwritten when calling a function. Volatile registers may be changed by the callee. Another way to think about it is that the responsibility of saving volatile registers is on the <i>caller</i> and the responsibility for saving nonvolatile registers is on the <i>callee</i>. The set of registers that are volatile is defined in the <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170#callercallee-saved-registers">x64 calling convention</a>.</li><li id=frame-pointer>The assembly snippet given there is a simplified version of what a compiler would generate. Typically, cl.exe will not generate frame pointers even if you disable FPO, but one way to force it is by using dynamically sized stack frames using <b>alloca</b>. If you do that, you will get something like this:<pre tabindex=0><code> 4055            push    rbp
 4883ec30        sub     rsp,30h
 488d6c2420      lea     rbp,[rsp+20h]
 ...
 488d6510        lea     rsp,[rbp+10h]
 5d              pop     rbp
 c3              ret
</code></pre></li><li id=fpo-speed>You'd think that saving a whole register would mean a performance improvement, right? Especially on 32-bit x86 code where registers are at a premium. But it turns out that the cost savings are really pretty neglible. A Microsoft <a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/sosp153-glerum-web.pdf>research paper from 2009</a> talks about measurements that were made in the performance of Windows with and without frame pointers. They found that there was <a href=https://twitter.com/timmisiak/status/1720476999192604717>*no* statistically provable benefit of FPO</a>, and it was decided to disable FPO in Windows XP SP2! A similar investigation was done by <a href=https://fedoraproject.org/wiki/Changes/fno-omit-frame-pointer#Benchmarking_of_the_performance_impact>Fedora</a> and it was found that performance was typically only 2% different. When Meta enabled frame pointers sometime around 2017, they compared performance between a comparable set of hosts with and without FPO and found no difference.<p>So why do we continue using FPO? Probably to make life more difficult for people who write debuggers.</p></li><li id=initial-state>The "initial state" of the context here really means the initial state of the non-volatile registers only. The called function has no responsibility to save volatile state, but since the calling function should not be relying on the volatile state, this will be "good enough" for unwinding the context for the purpose of looking at local variables, for instance.</li><li id=epilog-apply>Note that the unwind operations should *not* be applied if the instruction pointer is inside an epilog. We'll completely mess up the stack if we do. But in order to correctly unwind in an epilog, it means we need to do some basic disassembly. I'll leave that for the next post, since this is already way too long.</li><li id=taken-effect>Something interesting to note here is that the compiler often won't record that an unwind operation has occurred until there is a destructive operation that necessitates the unwind operation to be applied. Look at the previous example for KERNEL32!Module32NextW. The RBX register is saved at offset 0x3 in the function, and the value of RBX isn't overwritten until offset 0xE. So the unwind operation is recorded at offset 0xC, which is the instruction right before RBX is overwritten. This is because RBX doesn't *need* to be recovered until it's overwritten. So don't be surprised if the unwind operations don't seem to align perfectly with the assembly instructions that they seem to correspond to.<pre tabindex=0><code>Unwind info at 00007fff`018b8428, c bytes
version 1, flags 0, prolog c, codes 4
00: offs c, unwind op 4, op info 3	UWOP_SAVE_NONVOL FrameOffset: 60 reg: rbx.
02: offs c, unwind op 2, op info 9	UWOP_ALLOC_SMALL.
03: offs 8, unwind op 0, op info 7	UWOP_PUSH_NONVOL reg: rdi.
0:000&gt; uf KERNEL32!Module32NextW
KERNEL32!Module32NextW:
00007fff`01821010 4c8bdc          mov     r11,rsp
00007fff`01821013 49895b08        mov     qword ptr [r11+8],rbx
00007fff`01821017 57              push    rdi
00007fff`01821018 4883ec50        sub     rsp,50h
00007fff`0182101c 33ff            xor     edi,edi
00007fff`0182101e 488bda          mov     rbx,rdx
</code></pre></li><li id=push-ordering>Note that the order of operations is important here if the indicated register is RSP. If we add 8 to RSP and *then* write to RSP, then the value of RSP that we restored would be incorrect.</li><li id=when-to-stop>But how do we know when to stop walking the stack? There are a few termination conditions we can look for. Ordinarily we'll eventually find a return address of "0" which means there are no more frames. We could also look at the stack pointer and stop if it ever leaves the stack boundaries for a thread (specified in the TEB). Or you could look for a number of error conditions, like a stack pointer that doesn't change from one frame to the next, or even a stack pointer that moves in the wrong direction. Lots of things can go wrong, and a good debugger won't hang or crash just because some data gets messed up inside a target process.</li></ol></footer></div><div class=post-footer></div></article></main></body></html>